{"version":3,"sources":["../../src/core/materials.ts","../../src/OMOVIVisualizer.tsx","../../src/core/visualizer.ts","../../src/core/geometries/particles/particles.ts","../../src/core/geometries/particles/fragment.ts","../../src/core/geometries/bonds/bonds.ts","../../src/core/geometries/bonds/fragment.ts","../../src/core/atomtypes.ts","../../src/core/simulationdata/simulationdata.ts","../../src/core/simulationdata/simulationdataframe.ts","../../src/parsers/xyzparser.ts","App.tsx","../../src/utils/kdtree/binary-heap.ts","../../src/utils/kdtree/kdtree.ts","index.tsx"],"names":["constructor","materialType","parameters","copy","THREE","castedSource","this","defines","clone","material","Material","materialMap","createMaterial","color","value","_fragDepthSupported","renderer","gl","fragDepthSupported","shader","Object","inverseModelMatrix","modelViewMatrix","normalMatrix","inverseNormalMatrix","Visualizer","domElement","add","object","remove","setupLights","ambientLight","directionalLight","scene","setupCanvas","canvas","setupCamera","camera","updateUniforms","animate","requestAnimationFrame","resizeIfNeeded","rendererSize","rendererPixelWidth","rendererPixelHeight","clientWidth","clientHeight","clientPixelWidth","window","clientPixelHeight","clientTextureSize","scale","Math","width","height","adjustCamera","OMOVIVisualizer","bonds","useRef","useState","useEffect","newVisualizer","setVisualizer","prevParticlesRef","prevParticles","prevBondsRef","prevBonds","visualizer","particles","style","ref","capacity","getRadius","index","getPosition","getGeometry","baseGeometry","geometry","getMesh","matrix","i","Float32Array","r","g","b","count","radius","console","getPosition1","positions","positionBufferAttribute","indexBufferAttribute","Uint16Array","AtomTypes","H","fullname","He","Li","Be","B","C","N","O","F","Ne","Na","Mg","Al","Si","P","S","Cl","Ar","K","Ca","Sc","Ti","V","Cr","Mn","Fe","Co","Ni","Cu","Zn","Ga","Ge","As","Se","Br","Kr","Rb","Sr","Y","Zr","Nb","Mo","Tc","Ru","Rh","Pd","Ag","Cd","In","Sn","Sb","Te","I","Xe","Cs","Ba","La","Ce","Pr","Nd","Pm","Sm","Eu","Gd","Tb","Dy","Ho","Er","Tm","Yb","Lu","Hf","Ta","W","SimulationData","getFrame","frame","getNumFrames","SimulationDataFrame","addParticlesToFrame","lines","j","lineData","element","atomType","x","parseFloat","y","z","parseXyz","data","frames","numLines","skipNextLine","readNumParticles","numParticles","parseInt","isNaN","simulationData","scoreFunction","content","push","length","pop","result","end","peek","len","Error","size","bubbleUp","n","parentN","parent","sinkDown","elemScore","child1Score","child2N","child1N","swap","child1","child2","child2Score","reusableArray","points","metric","maxDepth","currentNode","indices","Uint32Array","Int32Array","buildTree","depth","plength","arrEnd","nodeIndex","nodes","arrMedian","arrBegin","currentDim","left","right","pivotValue","pivotIndex","tmp","storeIndex","getNodeDepth","parentIndex","nearest","bestNodes","e","nearestSearch","dimension","pointIndex","ownPoint","ownDistance","leftIndex","rightIndex","bestChild","point","saveNode","linearPoint","linearDistance","otherChild","il","verify","dim","positionsArray","random","generateBonds","pairs","tree","Kdtree","subarray","a","pow","position1","position2","maxDistance","distance","pairKey","max","Bonds","App","setData","setFrame","fetch","xyzFile","text","generateBondsFunction","downloadData","setTimeout","nextFrame","currentFrame","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.c1b1ab31.chunk.js","sourcesContent":["import * as THREE from 'three'\n\nexport interface Uniforms {\n  [name: string]: THREE.IUniform\n}\n\nexport interface Extensions {\n  fragDepth?: boolean\n}\n\nclass Material extends THREE.MeshPhongMaterial {\n  materialType: string\n  uniforms: Uniforms\n  extensions: Extensions\n\n  constructor(\n    materialType: string,\n    parameters?: THREE.MeshPhongMaterialParameters\n  ) {\n    super(parameters)\n    // @ts-ignore\n    this.materialType = materialType\n    this.uniforms = {}\n    this.extensions = {}\n    this.defines = {}\n  }\n\n  copy(source: THREE.Material): this {\n    THREE.MeshPhongMaterial.prototype.copy.call(this, source)\n    const castedSource = source as Material\n    this.type = castedSource.type\n    this.defines = { ...castedSource.defines }\n    this.extensions = castedSource.extensions\n    this.uniforms = castedSource.uniforms\n    this.onBeforeCompile = castedSource.onBeforeCompile\n    return this\n  }\n\n  clone(): this {\n    // three.js uses \"this\" for no good reason, and we need to match that\n    const material = new THREE.MeshPhongMaterial()\n    Material.prototype.copy.call(material, this)\n    return material as this\n  }\n}\n\nconst materialMap: { [key: string]: Material } = {}\nlet _fragDepthSupported: boolean | undefined\n\nfunction fragDepthSupported() {\n  if (_fragDepthSupported !== undefined) {\n    return _fragDepthSupported\n  }\n\n  const renderer = new THREE.WebGLRenderer()\n  const gl = renderer.domElement.getContext('webgl')\n\n  if (\n    renderer.capabilities.isWebGL2 ||\n    (gl != null && gl.getExtension('EXT_frag_depth') != null)\n  ) {\n    _fragDepthSupported = true\n  } else {\n    _fragDepthSupported = false\n  }\n\n  renderer.dispose()\n\n  return _fragDepthSupported\n}\n\nconst createMaterial = (\n  type: string,\n  vertexShader: string,\n  fragmentShader: string\n) => {\n  if (materialMap[type] != null) {\n    return materialMap[type]\n  }\n\n  const material = new Material(type, { color: 0xffffff })\n  material.uniforms.inverseModelMatrix = { value: new THREE.Matrix4() }\n  material.uniforms.inverseNormalMatrix = { value: new THREE.Matrix3() }\n\n  if (fragDepthSupported()) {\n    material.extensions.fragDepth = true\n    material.defines!.FRAG_DEPTH = 1\n  }\n\n  material.onBeforeCompile = (shader: THREE.Shader) => {\n    Object.assign(shader.uniforms, material.uniforms)\n    material.uniforms = shader.uniforms\n\n    shader.vertexShader = vertexShader\n    shader.fragmentShader = fragmentShader\n  }\n\n  // Necessary because of a bug in THREE.JS\n  // https://github.com/mrdoob/three.js/issues/15948\n  material.onBeforeCompile.toString = () => type\n\n  materialMap[type] = material\n  return material\n}\n\nexport default createMaterial\nexport { Material }\n","import React, { useEffect, useState, useRef } from 'react'\nimport Visualizer from './core/visualizer'\nimport Particles from './core/geometries/particles/particles'\nimport Bonds from './core/geometries/bonds/bonds'\n\nlet newVisualizer: Visualizer | undefined\n\nconst OMOVIVisualizer = ({\n  particles,\n  bonds\n}: {\n  particles?: Particles\n  bonds?: Bonds\n}) => {\n  const domElement = useRef<HTMLDivElement | null>(null)\n  const [visualizer, setVisualizer] = useState<Visualizer | undefined>(\n    undefined\n  )\n\n  useEffect(() => {\n    if (domElement.current && !newVisualizer) {\n      newVisualizer = new Visualizer(domElement.current)\n      setVisualizer(newVisualizer)\n    }\n  }, [domElement, visualizer])\n\n  const prevParticlesRef = useRef<Particles>()\n  useEffect(() => {\n    prevParticlesRef.current = particles\n  })\n  const prevParticles = prevParticlesRef.current\n\n  const prevBondsRef = useRef<Bonds>()\n  useEffect(() => {\n    prevBondsRef.current = bonds\n  })\n  const prevBonds = prevBondsRef.current\n\n  useEffect(() => {\n    if (!visualizer) {\n      return\n    }\n\n    if (prevParticles) {\n      visualizer.remove(prevParticles.getMesh())\n    }\n    if (particles) {\n      visualizer.add(particles.getMesh())\n    }\n\n    if (prevBonds) {\n      visualizer.remove(prevBonds.getMesh())\n    }\n    if (bonds) {\n      visualizer.add(bonds.getMesh())\n    }\n  }, [particles, bonds, visualizer])\n\n  return (\n    <div style={{ height: '100%', width: '100%' }}>\n      <div style={{ height: '100%', width: '100%' }} ref={domElement} />\n    </div>\n  )\n}\nexport default OMOVIVisualizer\n","import * as THREE from 'three'\nimport ComboControls from '@cognite/three-combo-controls'\nimport { Material } from './materials'\n\nconst inverseModelMatrix = new THREE.Matrix4()\nconst modelViewMatrix = new THREE.Matrix4()\nconst normalMatrix = new THREE.Matrix3()\nconst inverseNormalMatrix = new THREE.Matrix3()\n\nconst adjustCamera = (\n  camera: THREE.PerspectiveCamera,\n  width: number,\n  height: number\n) => {\n  if (camera instanceof THREE.PerspectiveCamera) {\n    camera.aspect = width / height\n  }\n  camera.updateProjectionMatrix()\n}\n\nexport default class Visualizer {\n  private renderer: THREE.WebGLRenderer\n  private canvas: HTMLCanvasElement\n  public scene: THREE.Scene\n  private camera: THREE.PerspectiveCamera\n  private ambientLight: THREE.AmbientLight\n  private directionalLight: THREE.DirectionalLight\n  private controls: ComboControls\n  private clock: THREE.Clock\n  private domElement: HTMLElement\n  private object: THREE.Object3D\n  private materials: { [key: string]: Material }\n\n  // @ts-ignore\n  private latestRequestId?: number\n\n  constructor(domElement: HTMLElement) {\n    this.renderer = new THREE.WebGLRenderer()\n\n    this.canvas = this.renderer.domElement\n    this.domElement = domElement\n    this.domElement.appendChild(this.canvas)\n    this.setupCanvas(this.canvas)\n\n    this.scene = new THREE.Scene()\n\n    this.ambientLight = new THREE.AmbientLight(0xffffff)\n    this.directionalLight = new THREE.DirectionalLight(0xffffff)\n    this.setupLights(this.ambientLight, this.directionalLight, this.scene)\n\n    this.camera = new THREE.PerspectiveCamera(60, 640 / 480, 0.1, 10000)\n    this.setupCamera(this.camera)\n    this.controls = new ComboControls(this.camera, this.canvas)\n\n    this.latestRequestId = undefined\n    this.clock = new THREE.Clock()\n    this.object = new THREE.Object3D()\n    this.scene.add(this.object)\n\n    this.materials = {}\n    this.animate()\n  }\n\n  add = (object: THREE.Mesh) => {\n    if (object == null) {\n      return\n    }\n\n    if (object.material instanceof Material) {\n      const material = object.material as Material\n      const materialType = material.type\n      if (this.materials[materialType] == null) {\n        this.materials[materialType] = material\n      }\n    }\n\n    this.object.add(object)\n  }\n\n  remove = (object: THREE.Mesh) => {\n    this.object.remove(object)\n  }\n\n  setupLights = (\n    ambientLight: THREE.AmbientLight,\n    directionalLight: THREE.DirectionalLight,\n    scene: THREE.Scene\n  ) => {\n    ambientLight.intensity = 0.3\n    directionalLight.intensity = 0.7\n    scene.add(directionalLight)\n    scene.add(ambientLight)\n  }\n\n  setupCanvas = (canvas: HTMLCanvasElement) => {\n    canvas.style.width = '640px'\n    canvas.style.height = '480px'\n    canvas.style.minWidth = '100%'\n    canvas.style.minHeight = '100%'\n    canvas.style.maxWidth = '100%'\n    canvas.style.maxHeight = '100%'\n  }\n\n  setupCamera = (camera: THREE.PerspectiveCamera) => {\n    camera.position.set(10, 10, 10)\n    camera.lookAt(new THREE.Vector3(0, 0, 0))\n  }\n\n  updateUniforms = (camera: THREE.PerspectiveCamera) => {\n    this.object.matrixWorld.copy(this.object.matrixWorld).invert()\n    modelViewMatrix\n      .copy(camera.matrixWorldInverse)\n      .multiply(this.object.matrixWorld)\n    normalMatrix.getNormalMatrix(modelViewMatrix)\n    inverseNormalMatrix.copy(normalMatrix).invert()\n\n    Object.values(this.materials).forEach((material) => {\n      if (material.uniforms.inverseModelMatrix != null) {\n        material.uniforms.inverseModelMatrix.value.copy(inverseModelMatrix)\n      }\n      if (material.uniforms.inverseNormalMatrix != null) {\n        material.uniforms.inverseNormalMatrix.value.copy(inverseNormalMatrix)\n      }\n    })\n  }\n\n  animate = () => {\n    this.resizeIfNeeded()\n    this.controls.update(this.clock.getDelta())\n    this.updateUniforms(this.camera)\n    this.renderer.render(this.scene, this.camera)\n    this.latestRequestId = requestAnimationFrame(this.animate.bind(this))\n    // console.log(this.camera.position.clone())\n  }\n\n  resizeIfNeeded = () => {\n    // The maxTextureSize is chosen from testing on low-powered hardware,\n    // and could be increased in the future.\n    // TODO Increase maxTextureSize if SSAO performance is improved\n    const maxTextureSize = 1.4e6\n\n    const rendererSize = this.renderer.getSize(new THREE.Vector2())\n    const rendererPixelWidth = rendererSize.width\n    const rendererPixelHeight = rendererSize.height\n\n    // client width and height are in virtual pixels and not yet scaled by dpr\n    // TODO VERSION 5.0.0 remove the test for dom element size once we have removed the getCanvas function\n    const clientWidth =\n      this.domElement.clientWidth !== 0\n        ? this.domElement.clientWidth\n        : this.canvas.clientWidth\n    const clientHeight =\n      this.domElement.clientHeight !== 0\n        ? this.domElement.clientHeight\n        : this.canvas.clientHeight\n    const clientPixelWidth = window.devicePixelRatio * clientWidth\n    const clientPixelHeight = window.devicePixelRatio * clientHeight\n    const clientTextureSize = clientPixelWidth * clientPixelHeight\n\n    const scale =\n      clientTextureSize > maxTextureSize\n        ? Math.sqrt(maxTextureSize / clientTextureSize)\n        : 1\n\n    const width = clientPixelWidth * scale\n    const height = clientPixelHeight * scale\n\n    const maxError = 0.1 // pixels\n    const isOptimalSize =\n      Math.abs(rendererPixelWidth - width) < maxError &&\n      Math.abs(rendererPixelHeight - height) < maxError\n\n    if (isOptimalSize) {\n      return false\n    }\n\n    this.renderer.setSize(width, height)\n\n    adjustCamera(this.camera, width, height)\n\n    return true\n  }\n}\n","import * as THREE from 'three'\nimport fragmentShader from './fragment'\nimport vertexShader from './vertex'\nimport createMaterial from 'core/materials'\n\nclass Particles {\n  positions: Float32Array\n  indices: Float32Array\n  radii: Float32Array\n  colors: THREE.Color[]\n  count: number\n  capacity: number\n  mesh?: THREE.InstancedMesh\n\n  constructor(capacity: number) {\n    this.positions = new Float32Array(3 * capacity)\n    this.indices = new Float32Array(capacity)\n    this.radii = new Float32Array(capacity)\n    this.colors = []\n    this.count = 0\n    this.capacity = capacity\n    this.mesh = undefined\n  }\n\n  add(\n    x: number,\n    y: number,\n    z: number,\n    radius: number,\n    r: number = 255.0,\n    g: number = 0.0,\n    b: number = 0.0\n  ) {\n    if (this.count === this.capacity) {\n      console.log(\"Warning, can't add particle because arrays are full\")\n      return\n    }\n\n    const index = this.count\n\n    this.positions[3 * index + 0] = x\n    this.positions[3 * index + 1] = y\n    this.positions[3 * index + 2] = z\n    this.colors.push(new THREE.Color(r / 255, g / 255, b / 255))\n    this.radii[index] = radius * 0.25\n    this.indices[index] = index\n\n    this.count += 1\n  }\n\n  getRadius = (index: number) => {\n    return this.radii[index]\n  }\n\n  getPosition = (index: number) => {\n    return new THREE.Vector3(\n      this.positions[3 * index + 0],\n      this.positions[3 * index + 1],\n      this.positions[3 * index + 2]\n    )\n  }\n\n  getGeometry = () => {\n    const baseGeometry = new THREE.PlaneBufferGeometry(1, 1, 1, 1)\n    const geometry = new THREE.InstancedBufferGeometry()\n\n    geometry.instanceCount = this.count\n    geometry.setIndex(baseGeometry.getIndex())\n    geometry.setAttribute('position', baseGeometry.getAttribute('position'))\n    geometry.setAttribute('normal', baseGeometry.getAttribute('normal'))\n\n    geometry.setAttribute(\n      'particlePosition',\n      new THREE.InstancedBufferAttribute(this.positions, 3, false, 1)\n    )\n    geometry.setAttribute(\n      'particleRadius',\n      new THREE.InstancedBufferAttribute(this.radii, 1, false, 1)\n    )\n    return geometry\n  }\n\n  getMesh = () => {\n    if (this.mesh != null) {\n      return this.mesh\n    }\n    const geometry = this.getGeometry()\n    const material = createMaterial('particle', vertexShader, fragmentShader)\n    this.mesh = new THREE.InstancedMesh(geometry, material, this.count)\n\n    const matrix = new THREE.Matrix4()\n    for (let i = 0; i < this.count; i++) {\n      this.mesh.setMatrixAt(i, matrix)\n      this.mesh.setColorAt(i, this.colors[i])\n    }\n    this.mesh.frustumCulled = false\n\n    return this.mesh\n  }\n}\n\nexport default Particles\n","export default /* glsl */ `\n#define PHONG\n\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n\nuniform mat4 projectionMatrix;\nvarying vec3 vSurfacePoint;\nvarying vec3 vCenter;\nvarying float vRadius;\n\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\n\tvec3 rayTarget = vSurfacePoint;\n\tvec3 rayDirection = normalize(rayTarget); // rayOrigin is (0,0,0) in camera space\n\n\tvec3 diff = rayTarget - vCenter.xyz;\n    vec3 E = diff;\n    vec3 D = rayDirection;\n\n    float a = dot(D, D);\n    float b = dot(E, D);\n    float c = dot(E, E) - vRadius*vRadius;\n\n    // discriminant of sphere equation (factor 2 removed from b above)\n    float d = b*b - a*c;\n    if(d < 0.0)\n        discard;\n\t\n    float sqrtd = sqrt(d);\n    float dist1 = (-b - sqrtd)/a;\n    float dist2 = (-b + sqrtd)/a;\n\n    // Make sure dist1 is the smaller one\n    if (dist2 < dist1) {\n        float tmp = dist1;\n        dist1 = dist2;\n        dist2 = tmp;\n    }\n\n    float dist = dist1;\n    float intersectionPointZ = E.z + dist*D.z;\n\tvec3 p = rayTarget + dist*rayDirection;\n\n\t// Find normal vector in local space\n    normal = normalize(vec3(p - vCenter.xyz));\n    // Transform into camera space\n    if (dot(normal, rayDirection) >  0.) {\n        normal = -normal;\n    }\n\n#ifdef FRAG_DEPTH\n\tfloat projectedIntersection_z = projectionMatrix[0][2]*p.x + projectionMatrix[1][2]*p.y + projectionMatrix[2][2]*p.z + projectionMatrix[3][2];\n\tfloat projectedIntersection_w = projectionMatrix[0][3]*p.x + projectionMatrix[1][3]*p.y + projectionMatrix[2][3]*p.z + projectionMatrix[3][3];\n\tgl_FragDepthEXT = ((gl_DepthRange.diff * (projectedIntersection_z / projectedIntersection_w)) + gl_DepthRange.near + gl_DepthRange.far) * 0.5;\n#endif\n\n\t#include <emissivemap_fragment>\n\n\t// accumulation\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\n\t// modulation\n\t#include <aomap_fragment>\n\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\n\t#include <envmap_fragment>\n\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n\n}\n`\n","import * as THREE from 'three'\nimport fragmentShader from './fragment'\nimport vertexShader from './vertex'\nimport createMaterial from 'core/materials'\n\nclass Bonds {\n  positions1: Float32Array\n  positions2: Float32Array\n  indices: Float32Array\n  radii: Float32Array\n  colors: THREE.Color[]\n  count: number\n  capacity: number\n  mesh?: THREE.InstancedMesh\n\n  constructor(capacity: number) {\n    this.positions1 = new Float32Array(3 * capacity)\n    this.positions2 = new Float32Array(3 * capacity)\n    this.indices = new Float32Array(capacity)\n    this.radii = new Float32Array(capacity)\n    this.colors = []\n    this.count = 0\n    this.capacity = capacity\n    this.mesh = undefined\n  }\n\n  add(\n    x1: number,\n    y1: number,\n    z1: number,\n    x2: number,\n    y2: number,\n    z2: number,\n    radius: number,\n    r: number = 255.0,\n    g: number = 255.0,\n    b: number = 255.0\n  ) {\n    if (this.count === this.capacity) {\n      console.log(\"Warning, can't add particle because arrays are full\")\n      return\n    }\n\n    const index = this.count\n\n    this.positions1[3 * index + 0] = x1\n    this.positions1[3 * index + 1] = y1\n    this.positions1[3 * index + 2] = z1\n    this.positions2[3 * index + 0] = x2\n    this.positions2[3 * index + 1] = y2\n    this.positions2[3 * index + 2] = z2\n\n    this.colors.push(new THREE.Color(r / 255, g / 255, b / 255))\n\n    this.radii[index] = radius * 0.25\n    this.indices[index] = index\n\n    this.count += 1\n  }\n\n  getRadius = (index: number) => {\n    return this.radii[index]\n  }\n\n  getPosition1 = (index: number) => {\n    return new THREE.Vector3(\n      this.positions1[3 * index + 0],\n      this.positions1[3 * index + 1],\n      this.positions1[3 * index + 2]\n    )\n  }\n\n  getGeometry = () => {\n    const positions = []\n    positions.push(-1, 1, -1)\n    positions.push(-1, -1, -1)\n    positions.push(1, 1, -1)\n    positions.push(1, -1, -1)\n    positions.push(1, 1, 1)\n    positions.push(1, -1, 1)\n\n    const positionBufferAttribute = new THREE.BufferAttribute(\n      new Float32Array(positions),\n      3\n    )\n    const indexBufferAttribute = new THREE.BufferAttribute(\n      new Uint16Array([1, 2, 0, 1, 3, 2, 3, 4, 2, 3, 5, 4]),\n      1\n    )\n\n    const geometry = new THREE.InstancedBufferGeometry()\n\n    geometry.instanceCount = this.count\n    geometry.setIndex(indexBufferAttribute)\n    geometry.setAttribute('position', positionBufferAttribute)\n    geometry.setAttribute('normal', positionBufferAttribute)\n\n    geometry.setAttribute(\n      'position1',\n      new THREE.InstancedBufferAttribute(this.positions1, 3, false, 1)\n    )\n\n    geometry.setAttribute(\n      'position2',\n      new THREE.InstancedBufferAttribute(this.positions2, 3, false, 1)\n    )\n\n    geometry.setAttribute(\n      'bondRadius',\n      new THREE.InstancedBufferAttribute(this.radii, 1, false, 1)\n    )\n\n    return geometry\n  }\n\n  getMesh = () => {\n    if (this.mesh != null) {\n      return this.mesh\n    }\n\n    if (this.count === 0) {\n      return null\n    }\n\n    const geometry = this.getGeometry()\n    const material = createMaterial('bonds', vertexShader, fragmentShader)\n    this.mesh = new THREE.InstancedMesh(geometry, material, this.count)\n\n    const matrix = new THREE.Matrix4()\n    for (let i = 0; i < this.count; i++) {\n      this.mesh.setMatrixAt(i, matrix)\n      this.mesh.setColorAt(i, this.colors[i])\n    }\n    this.mesh.frustumCulled = false\n\n    return this.mesh\n  }\n}\n\nexport default Bonds\n","export default /* glsl */ `\n#define PHONG\n\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n\nuniform mat4 projectionMatrix;\nvarying vec4 v_position1;\nvarying vec4 v_position2;\nvarying vec4 U;\nvarying vec4 V;\nvarying vec4 axis;\nvarying float height;\n\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\n\tmat3 basis = mat3(U.xyz, V.xyz, axis.xyz);\n    vec3 surfacePoint = vec3(U.w, V.w, axis.w);\n    vec3 rayTarget = surfacePoint;\n\tvec3 rayDirection = normalize(rayTarget); // rayOrigin is (0,0,0) in camera space\n\n\tvec3 diff = rayTarget - v_position2.xyz;\n    vec3 E = diff * basis;\n    float L = height;\n    vec3 D = rayDirection * basis;\n\n    float R1 = v_position1.w;\n    float R2 = v_position2.w;\n    float dR = R2 - R1;\n\n    float a = dot(D.xy, D.xy);\n    float b = dot(E.xy, D.xy);\n    float c = dot(E.xy, E.xy)-R1*R1;\n    float L2Inv = 1.0/(L*L);\n\n\t// Calculate a dicriminant of the above quadratic equation (factor 2 removed from all b-terms above)\n    float d = b*b - a*c;\n\n    // d < 0.0 means the ray hits outside an infinitely long eccentric cone\n    if (d < 0.0) {\n\t\tdiscard;\n    }\n\n\tfloat sqrtd = sqrt(d);\n    float dist1 = (-b - sqrtd)/a;\n    float dist2 = (-b + sqrtd)/a;\n\n    // Make sure dist1 is the smaller one\n    if (dist2 < dist1) {\n      float tmp = dist1;\n      dist1 = dist2;\n      dist2 = tmp;\n    }\n\n\t// Check the smallest root, it is closest camera. Only test if the z-component is outside the truncated eccentric cone\n    float dist = dist1;\n    float intersectionPointZ = E.z + dist*D.z;\n    // Intersection point in camera space\n    vec3 p = rayTarget + dist*rayDirection;\n    bool isInner = false;\n\n    if (intersectionPointZ <= 0.0 ||\n      intersectionPointZ >= L\n      ) {\n      // Either intersection point is behind starting point (happens inside the cone),\n      // or the intersection point is outside the end caps. This is not a valid solution.\n      isInner = true;\n      dist = dist2;\n      intersectionPointZ = E.z + dist*D.z;\n      p = rayTarget + dist*rayDirection;\n\n      if (intersectionPointZ <= 0.0 ||\n        intersectionPointZ >= L\n      ) {\n        // Missed the other point too\n\t\tdiscard;\n      }\n    }\n\n\t// Find normal vector\n    vec3 n = normalize(-axis.xyz);\n    vec3 position1 = v_position1.xyz;\n    vec3 position2 = v_position2.xyz;\n    vec3 A = cross(position1 - p, position2 - p);\n\n    vec3 t = normalize(cross(n, A));\n    vec3 o1 = position1 + R1 * t;\n    vec3 o2 = position2 + R2 * t;\n    vec3 B = o2-o1;\n    normal = normalize(cross(A, B));\n\n#ifdef FRAG_DEPTH\n\tfloat projectedIntersection_z = projectionMatrix[0][2]*p.x + projectionMatrix[1][2]*p.y + projectionMatrix[2][2]*p.z + projectionMatrix[3][2];\n\tfloat projectedIntersection_w = projectionMatrix[0][3]*p.x + projectionMatrix[1][3]*p.y + projectionMatrix[2][3]*p.z + projectionMatrix[3][3];\n\tgl_FragDepthEXT = ((gl_DepthRange.diff * (projectedIntersection_z / projectedIntersection_w)) + gl_DepthRange.near + gl_DepthRange.far) * 0.5;\n#endif\n\n\t#include <emissivemap_fragment>\n\n\t// accumulation\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\n\t// modulation\n\t#include <aomap_fragment>\n\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\n\t#include <envmap_fragment>\n\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n  \n}\n\n`\n","export interface Color {\n  r: number\n  g: number\n  b: number\n}\n\nexport interface AtomType {\n  fullname: string\n  radius: number\n  color: Color\n}\n\nconst AtomTypes: { [key: string]: AtomType } = {\n  H: { fullname: 'hydrogen', radius: 1.2, color: { r: 204, g: 204, b: 204 } },\n  He: { fullname: 'helium', radius: 1.4, color: { r: 217, g: 255, b: 255 } },\n  Li: { fullname: 'lithium', radius: 1.82, color: { r: 204, g: 128, b: 255 } },\n  Be: { fullname: 'beryllium', radius: 1.53, color: { r: 194, g: 255, b: 0 } },\n  B: { fullname: 'boron', radius: 1.92, color: { r: 255, g: 181, b: 181 } },\n  C: { fullname: 'carbon', radius: 1.7, color: { r: 80, g: 80, b: 80 } },\n  N: { fullname: 'nitrogen', radius: 1.55, color: { r: 48, g: 80, b: 248 } },\n  O: { fullname: 'oxygen', radius: 1.52, color: { r: 170, g: 0, b: 0 } },\n  F: { fullname: 'fluorine', radius: 1.35, color: { r: 144, g: 224, b: 80 } },\n  Ne: { fullname: 'neon', radius: 1.54, color: { r: 48, g: 80, b: 248 } },\n  Na: { fullname: 'sodium', radius: 2.27, color: { r: 171, g: 92, b: 242 } },\n  Mg: { fullname: 'magnesium', radius: 1.73, color: { r: 138, g: 255, b: 0 } },\n  Al: {\n    fullname: 'aluminium',\n    radius: 1.84,\n    color: { r: 191, g: 166, b: 166 }\n  },\n  Si: { fullname: 'silicon', radius: 2.27, color: { r: 240, g: 200, b: 160 } },\n  P: { fullname: 'phosphorus', radius: 1.8, color: { r: 255, g: 128, b: 0 } },\n  S: { fullname: 'sulfur', radius: 1.8, color: { r: 255, g: 255, b: 48 } },\n  Cl: { fullname: 'chlorine', radius: 1.75, color: { r: 31, g: 240, b: 31 } },\n  Ar: { fullname: 'argon', radius: 1.88, color: { r: 128, g: 209, b: 227 } },\n  K: { fullname: 'potassium', radius: 2.75, color: { r: 143, g: 64, b: 212 } },\n  Ca: { fullname: 'calcium', radius: 2.31, color: { r: 61, g: 255, b: 0 } },\n  Sc: { fullname: 'scandium', radius: 2.11, color: { r: 230, g: 230, b: 230 } },\n  Ti: { fullname: 'titanium', radius: 2.0, color: { r: 191, g: 194, b: 199 } },\n  V: { fullname: 'vanadium', radius: 2.0, color: { r: 166, g: 166, b: 171 } },\n  Cr: { fullname: 'chromium', radius: 2.0, color: { r: 138, g: 153, b: 199 } },\n  Mn: { fullname: 'manganese', radius: 2.0, color: { r: 156, g: 122, b: 199 } },\n  Fe: { fullname: 'iron', radius: 2.0, color: { r: 224, g: 102, b: 51 } },\n  Co: { fullname: 'cobalt', radius: 2.0, color: { r: 240, g: 144, b: 160 } },\n  Ni: { fullname: 'nickel', radius: 1.63, color: { r: 80, g: 208, b: 80 } },\n  Cu: { fullname: 'copper', radius: 1.4, color: { r: 200, g: 128, b: 51 } },\n  Zn: { fullname: 'zinc', radius: 1.39, color: { r: 125, g: 128, b: 176 } },\n  Ga: { fullname: 'gallium', radius: 1.87, color: { r: 194, g: 143, b: 143 } },\n  Ge: {\n    fullname: 'germanium',\n    radius: 2.11,\n    color: { r: 102, g: 143, b: 143 }\n  },\n  As: { fullname: 'arsenic', radius: 1.85, color: { r: 189, g: 128, b: 227 } },\n  Se: { fullname: 'selenium', radius: 1.9, color: { r: 255, g: 161, b: 0 } },\n  Br: { fullname: 'bromine', radius: 1.85, color: { r: 166, g: 41, b: 41 } },\n  Kr: { fullname: 'krypton', radius: 2.02, color: { r: 92, g: 184, b: 209 } },\n  Rb: { fullname: 'rubidium', radius: 3.03, color: { r: 112, g: 46, b: 176 } },\n  Sr: { fullname: 'strontium', radius: 2.49, color: { r: 0, g: 255, b: 0 } },\n  Y: { fullname: 'yttrium', radius: 2.0, color: { r: 148, g: 255, b: 255 } },\n  Zr: { fullname: 'zirconium', radius: 2.0, color: { r: 148, g: 224, b: 224 } },\n  Nb: { fullname: 'niobium', radius: 2.0, color: { r: 115, g: 194, b: 201 } },\n  Mo: { fullname: 'molybdenum', radius: 2.0, color: { r: 84, g: 181, b: 181 } },\n  Tc: { fullname: 'technetium', radius: 2.0, color: { r: 59, g: 158, b: 158 } },\n  Ru: { fullname: 'ruthenium', radius: 2.0, color: { r: 36, g: 143, b: 143 } },\n  Rh: { fullname: 'rhodium', radius: 2.0, color: { r: 10, g: 125, b: 140 } },\n  Pd: { fullname: 'palladium', radius: 1.63, color: { r: 0, g: 105, b: 133 } },\n  Ag: { fullname: 'silver', radius: 1.72, color: { r: 192, g: 192, b: 192 } },\n  Cd: { fullname: 'cadmium', radius: 1.58, color: { r: 255, g: 217, b: 143 } },\n  In: { fullname: 'indium', radius: 1.93, color: { r: 166, g: 117, b: 115 } },\n  Sn: { fullname: 'tin', radius: 2.17, color: { r: 102, g: 128, b: 128 } },\n  Sb: { fullname: 'antimony', radius: 2.06, color: { r: 158, g: 99, b: 181 } },\n  Te: { fullname: 'tellurium', radius: 2.06, color: { r: 212, g: 122, b: 0 } },\n  I: { fullname: 'iodine', radius: 1.98, color: { r: 148, g: 0, b: 148 } },\n  Xe: { fullname: 'xenon', radius: 2.16, color: { r: 66, g: 158, b: 176 } },\n  Cs: { fullname: 'caesium', radius: 3.43, color: { r: 87, g: 23, b: 143 } },\n  Ba: { fullname: 'barium', radius: 2.68, color: { r: 0, g: 201, b: 0 } },\n  La: { fullname: 'lanthanum', radius: 2.0, color: { r: 112, g: 212, b: 255 } },\n  Ce: { fullname: 'cerium', radius: 2.0, color: { r: 255, g: 255, b: 199 } },\n  Pr: {\n    fullname: 'praseodymium',\n    radius: 2.0,\n    color: { r: 217, g: 255, b: 199 }\n  },\n  Nd: { fullname: 'neodymium', radius: 2.0, color: { r: 199, g: 255, b: 199 } },\n  Pm: {\n    fullname: 'promethium',\n    radius: 2.0,\n    color: { r: 163, g: 255, b: 199 }\n  },\n  Sm: { fullname: 'samarium', radius: 2.0, color: { r: 143, g: 255, b: 199 } },\n  Eu: { fullname: 'europium', radius: 2.0, color: { r: 97, g: 255, b: 199 } },\n  Gd: { fullname: 'gadolinium', radius: 2.0, color: { r: 69, g: 255, b: 199 } },\n  Tb: { fullname: 'terbium', radius: 2.0, color: { r: 48, g: 255, b: 199 } },\n  Dy: { fullname: 'dysprosium', radius: 2.0, color: { r: 31, g: 255, b: 199 } },\n  Ho: { fullname: 'holmium', radius: 2.0, color: { r: 0, g: 255, b: 156 } },\n  Er: { fullname: 'erbium', radius: 2.0, color: { r: 0, g: 230, b: 117 } },\n  Tm: { fullname: 'thulium', radius: 2.0, color: { r: 0, g: 212, b: 82 } },\n  Yb: { fullname: 'ytterbium', radius: 2.0, color: { r: 0, g: 191, b: 56 } },\n  Lu: { fullname: 'lutetium', radius: 2.0, color: { r: 0, g: 171, b: 36 } },\n  Hf: { fullname: 'hafnium', radius: 2.0, color: { r: 77, g: 194, b: 255 } },\n  Ta: { fullname: 'tantalum', radius: 2.0, color: { r: 77, g: 166, b: 255 } },\n  W: { fullname: 'tungsten', radius: 2.0, color: { r: 33, g: 148, b: 214 } }\n}\n\nexport default AtomTypes\n","import SimulationDataFrame from './simulationdataframe'\nimport Bonds from 'core/geometries/bonds/bonds'\n\nexport default class SimulationData {\n  frames: SimulationDataFrame[]\n  generateBondsFunction?: (frame: SimulationDataFrame) => Bonds\n  constructor() {\n    this.frames = []\n  }\n\n  getFrame = (index: number) => {\n    const frame = this.frames[index]\n    if (this.generateBondsFunction && frame.bonds == null) {\n      const bonds = this.generateBondsFunction(frame)\n      if (bonds.count > 0) {\n        frame.bonds = bonds\n      }\n    }\n\n    return frame\n  }\n\n  getNumFrames = () => {\n    return this.frames.length\n  }\n}\n","import Particles from 'core/geometries/particles/particles'\nimport Bonds from 'core/geometries/bonds/bonds'\n\nexport default class SimulationDataFrame {\n  particles: Particles\n  bonds?: Bonds\n  constructor(particles: Particles) {\n    this.particles = particles\n  }\n}\n","import Particles from 'core/geometries/particles/particles'\nimport AtomTypes from 'core/atomtypes'\nimport SimulationData from 'core/simulationdata/simulationdata'\nimport SimulationDataFrame from 'core/simulationdata/simulationdataframe'\n\nfunction addParticlesToFrame(lines: string[], i: number, particles: Particles) {\n  for (let j = 0; j < particles.capacity; j++) {\n    const lineData = lines[i + j].split(/\\s+/).filter(Boolean)\n    const element = lineData[0]\n\n    const atomType = AtomTypes[element]\n    let color = { r: 255, g: 102, b: 102 }\n    let radius = 1.0\n    if (atomType) {\n      radius = atomType.radius\n      color = atomType.color\n    }\n    const x = parseFloat(lineData[1])\n    const y = parseFloat(lineData[2])\n    const z = parseFloat(lineData[3])\n\n    particles.add(x, y, z, radius, color.r, color.g, color.b)\n  }\n}\n\nconst parseXyz = (data: string): SimulationData => {\n  let particles: Particles | undefined\n  const frames: SimulationDataFrame[] = []\n\n  const lines = data.split('\\n')\n  const numLines = lines.length\n  let i = 0\n  let skipNextLine = false\n  let readNumParticles = true\n\n  while (i < numLines) {\n    if (lines[i] === '') {\n      i++\n      continue\n    }\n\n    if (skipNextLine) {\n      skipNextLine = false\n    } else if (readNumParticles) {\n      const numParticles = parseInt(lines[i], 10)\n\n      if (isNaN(numParticles)) {\n        console.log('Warning, got NaN as numParticles')\n        break\n      }\n\n      particles = new Particles(numParticles)\n      readNumParticles = false\n      skipNextLine = true\n    } else {\n      if (particles) {\n        addParticlesToFrame(lines, i, particles)\n        const frame = new SimulationDataFrame(particles)\n        frames.push(frame)\n        i += particles.count - 1\n        readNumParticles = true\n      }\n    }\n\n    i++\n  }\n\n  const simulationData = new SimulationData()\n  simulationData.frames = frames\n\n  return simulationData\n}\n\nexport default parseXyz\n","import React, {useEffect, useState} from 'react'\nimport * as THREE from 'three'\n\nimport { OMOVIVisualizer, Particles, Bonds, Kdtree, SimulationData, SimulationDataFrame, parseXyz } from 'omovi'\n//@ts-ignore\n// import {kdTree} from 'kd-tree-javascript'\nimport 'omovi/dist/index.css'\n\n// const particles = new Particles(2)\n// particles.add(-1, 0, 0, 0.5);\n// particles.add(1, 0, 0, 0.5);\n\n// const bonds = new Bonds(1)\n// bonds.add(-1, 0, 0, 1, 0, 0, 0.1)\n\nconst positions: THREE.Vector3[] = []\nconst positionsArray: Float32Array = new Float32Array(30000)\nfor (let i = 0; i < 10000; i++) {\n  const x = Math.random() * 100\n  const y = Math.random() * 100\n  const z = Math.random() * 100\n  positions.push(new THREE.Vector3(x,y,z))\n  positionsArray[3 * i + 0] = x\n  positionsArray[3 * i + 1] = y\n  positionsArray[3 * i + 2] = z\n}\n\nconst generateBonds = (frame: SimulationDataFrame) => {\n  const radius = 0.5\n  const particles = frame.particles\n  const distance = (a: Float32Array, b: Float32Array) => {\n    return Math.pow(a[0]-b[0], 2) + Math.pow(a[1]-b[1], 2) + Math.pow(a[2]-b[2], 2);\n  }\n  \n  const pairs: {[key: string]: boolean} = {}\n\n  var tree = new Kdtree(particles.positions.subarray(0, 3 * particles.count), distance);\n\n  const position1: THREE.Vector3[] = []\n  const position2: THREE.Vector3[] = []\n\n  let maxDistance = 0\n  for (let i = 0; i < particles.count; i++) {\n    const nearest = tree.nearest(particles.positions.subarray(3 * i, 3 * (i+1)), 4, 1.4);\n    for (let j = 0; j < nearest.length; j++) {\n      const nodeIndex = nearest[j][0]\n      const index = tree.indices[ tree.nodes[ nodeIndex ] ]\n      const distance = nearest[j][1]\n      if (index === i) {\n        // Skip ourselves, as we always will find that with distance zero\n        continue\n      }\n      const pairKey = index < i ? `${index}-${i}` : `${i}-${index}`\n      maxDistance = Math.max(maxDistance, distance);\n      \n      if (pairs[pairKey] == null) {\n        position1.push(particles.getPosition(i))\n        position2.push(particles.getPosition(index))\n        pairs[pairKey] = true\n      }\n    }\n  }\n\n  const bonds = new Bonds(position1.length)\n  for (let i = 0; i < position1.length; i++) {\n    bonds.add(position1[i].x, position1[i].y, position1[i].z, position2[i].x, position2[i].y, position2[i].z, radius)\n  }\n\n  return bonds\n}\n\nconst App = () => {\n  const [data, setData] = useState<SimulationData>()\n  const [frame, setFrame] = useState<number>(0)\n  \n  useEffect(() => {\n    const downloadData = async () => {\n      const xyzFile = await fetch(\"https://raw.githubusercontent.com/andeplane/simulations/main/water.xyz\")\n      const simulationData = parseXyz(await xyzFile.text())\n      simulationData.generateBondsFunction = generateBonds\n      setData(simulationData)\n    }\n    downloadData()\n\n  }, [])\n\n  setTimeout(() => {\n    if (data == null) {\n      return\n    }\n\n    let nextFrame = frame + 1\n    if (nextFrame >= data.getNumFrames()) {\n      nextFrame = 0\n    }\n    setFrame(nextFrame)\n  }, 50)\n  \n  if (data == null) {\n    return <>Downloading simulation data ...</>\n  }\n  const currentFrame = data.getFrame(frame)\n  // test()\n  return <OMOVIVisualizer particles={currentFrame.particles} bonds={currentFrame.bonds} />\n}\n\nexport default App\n","/**\n * @file Binary Heap\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\n * @private\n */\n\n/**\n * Binary heap implementation\n * @class\n * @author http://eloquentjavascript.net/appendix2.htm\n * @param {Function} scoreFunction - the heap scoring function\n */\nclass BinaryHeap<T> {\n  content: T[] = []\n\n  constructor(readonly scoreFunction: (x: T) => number) {\n    this.scoreFunction = scoreFunction\n  }\n\n  push(element: T) {\n    // Add the new element to the end of the array.\n    this.content.push(element)\n\n    // Allow it to bubble up.\n    this.bubbleUp(this.content.length - 1)\n  }\n\n  pop() {\n    // Store the first element so we can return it later.\n    const result = this.content[0]\n\n    // Get the element at the end of the array.\n    const end = this.content.pop()\n\n    // If there are any elements left, put the end element at the\n    // start, and let it sink down.\n    if (end && this.content.length > 0) {\n      this.content[0] = end\n      this.sinkDown(0)\n    }\n\n    return result\n  }\n\n  peek() {\n    return this.content[0]\n  }\n\n  remove(element: T) {\n    const len = this.content.length\n\n    // To remove a value, we must search through the array to find it.\n    for (let i = 0; i < len; i++) {\n      if (this.content[i] === element) {\n        // When it is found, the process seen in 'pop' is repeated\n        // to fill up the hole.\n        const end = this.content.pop()\n\n        if (end && i !== len - 1) {\n          this.content[i] = end\n\n          if (this.scoreFunction(end) < this.scoreFunction(element)) {\n            this.bubbleUp(i)\n          } else {\n            this.sinkDown(i)\n          }\n        }\n\n        return\n      }\n    }\n\n    throw new Error('Node not found.')\n  }\n\n  size() {\n    return this.content.length\n  }\n\n  bubbleUp(n: number) {\n    // Fetch the element that has to be moved.\n    const element = this.content[n]\n\n    // When at 0, an element can not go up any further.\n    while (n > 0) {\n      // Compute the parent element's index, and fetch it.\n      const parentN = Math.floor((n + 1) / 2) - 1\n      const parent = this.content[parentN]\n\n      // Swap the elements if the parent is greater.\n      if (this.scoreFunction(element) < this.scoreFunction(parent)) {\n        this.content[parentN] = element\n        this.content[n] = parent\n\n        // Update 'n' to continue at the new position.\n        n = parentN\n      } else {\n        // Found a parent that is less, no need to move it further.\n        break\n      }\n    }\n  }\n\n  sinkDown(n: number) {\n    // Look up the target element and its score.\n    const length = this.content.length\n    const element = this.content[n]\n    const elemScore = this.scoreFunction(element)\n\n    let child1Score = 0\n    let child2Score = 0\n\n    while (true) {\n      // Compute the indices of the child elements.\n      const child2N = (n + 1) * 2\n      const child1N = child2N - 1\n\n      // This is used to store the new position of the element, if any.\n      let swap = null\n\n      // If the first child exists (is inside the array)...\n      if (child1N < length) {\n        // Look it up and compute its score.\n        const child1 = this.content[child1N]\n        child1Score = this.scoreFunction(child1)\n\n        // If the score is less than our element's, we need to swap.\n        if (child1Score < elemScore) swap = child1N\n      }\n\n      // Do the same checks for the other child.\n      if (child2N < length) {\n        const child2 = this.content[child2N]\n        child2Score = this.scoreFunction(child2)\n\n        if (child2Score < (swap === null ? elemScore : child1Score))\n          swap = child2N\n      }\n\n      // If the element needs to be moved, swap it, and continue.\n      if (swap !== null) {\n        this.content[n] = this.content[swap]\n        this.content[swap] = element\n        n = swap\n      } else {\n        // Otherwise, we are done.\n        break\n      }\n    }\n  }\n}\n\nexport default BinaryHeap\n","/**\n * @file Kdtree\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\n * @private\n */\n\nimport BinaryHeap from './binary-heap'\n\n/**\n * Kdtree\n * @class\n * @author Alexander Rose <alexander.rose@weirdbyte.de>, 2016\n * @author Roman Bolzern <roman.bolzern@fhnw.ch>, 2013\n * @author I4DS http://www.fhnw.ch/i4ds, 2013\n * @license MIT License <http://www.opensource.org/licenses/mit-license.php>\n * @description\n * k-d Tree for typed arrays of 3d points (e.g. for Float32Array), in-place\n * provides fast nearest neighbour search\n *\n * Based on https://github.com/ubilabs/kd-tree-javascript by Ubilabs\n *\n * Further information (including mathematical properties)\n * http://en.wikipedia.org/wiki/Binary_tree\n * http://en.wikipedia.org/wiki/K-d_tree\n *\n * @example\n * points: [x, y, z, x, y, z, x, y, z, ...]\n * metric: function(a, b){\n *    return Math.pow(a[0]-b[0], 2) + Math.pow(a[1]-b[1], 2) + Math.pow(a[2]-b[2], 2);\n * }\n *\n * @param {Float32Array} points - points\n * @param {Function} metric - metric\n */\n\nconst reusableArray = new Float32Array(3)\n\nclass Kdtree {\n  indices: Uint32Array\n  nodes: Int32Array\n  rootIndex: number\n\n  maxDepth = 0\n  currentNode = 0\n\n  constructor(\n    readonly points: Float32Array,\n    readonly metric: (a: Float32Array, b: Float32Array) => number\n  ) {\n    const n = points.length / 3\n\n    const indices = new Uint32Array(n)\n    for (let i = 0; i < n; ++i) {\n      indices[i] = i\n    }\n    this.indices = indices\n    this.nodes = new Int32Array(n * 4)\n    this.rootIndex = this.buildTree(0, -1, 0, n)\n  }\n\n  buildTree(depth: number, parent: number, arrBegin: number, arrEnd: number) {\n    if (depth > this.maxDepth) this.maxDepth = depth\n\n    const plength = arrEnd - arrBegin\n    if (plength === 0) {\n      return -1\n    }\n\n    const nodeIndex = this.currentNode * 4\n    const nodes = this.nodes\n\n    this.currentNode += 1\n    if (plength === 1) {\n      nodes[nodeIndex] = arrBegin\n      nodes[nodeIndex + 1] = -1\n      nodes[nodeIndex + 2] = -1\n      nodes[nodeIndex + 3] = parent\n      return nodeIndex\n    }\n    // if(plength <= 32){\n    //   return nodeIndex;\n    // }\n\n    const indices = this.indices\n    const points = this.points\n\n    const arrMedian = arrBegin + Math.floor(plength / 2)\n    const currentDim = depth % 3\n\n    // inlined quickselect function\n    let j, tmp, pivotIndex, pivotValue, storeIndex\n    let left = arrBegin\n    let right = arrEnd - 1\n    while (right > left) {\n      pivotIndex = (left + right) >> 1\n      pivotValue = points[indices[pivotIndex] * 3 + currentDim]\n      // swap( pivotIndex, right );\n      tmp = indices[pivotIndex]\n      indices[pivotIndex] = indices[right]\n      indices[right] = tmp\n      storeIndex = left\n      for (j = left; j < right; ++j) {\n        if (points[indices[j] * 3 + currentDim] < pivotValue) {\n          // swap( storeIndex, j );\n          tmp = indices[storeIndex]\n          indices[storeIndex] = indices[j]\n          indices[j] = tmp\n          ++storeIndex\n        }\n      }\n      // swap( right, storeIndex );\n      tmp = indices[right]\n      indices[right] = indices[storeIndex]\n      indices[storeIndex] = tmp\n      pivotIndex = storeIndex\n      if (arrMedian === pivotIndex) {\n        break\n      } else if (arrMedian < pivotIndex) {\n        right = pivotIndex - 1\n      } else {\n        left = pivotIndex + 1\n      }\n    }\n\n    nodes[nodeIndex] = arrMedian\n    nodes[nodeIndex + 1] = this.buildTree(\n      depth + 1,\n      nodeIndex,\n      arrBegin,\n      arrMedian\n    )\n    nodes[nodeIndex + 2] = this.buildTree(\n      depth + 1,\n      nodeIndex,\n      arrMedian + 1,\n      arrEnd\n    )\n    nodes[nodeIndex + 3] = parent\n\n    return nodeIndex\n  }\n\n  getNodeDepth(nodeIndex: number): number {\n    const parentIndex = this.nodes[nodeIndex + 3]\n    return parentIndex === -1 ? 0 : this.getNodeDepth(parentIndex) + 1\n  }\n\n  // TODO\n  // function getNodePos (node) {}\n\n  /**\n   * find nearest points\n   * @param {Array} point - array of size 3\n   * @param {Integer} maxNodes - max amount of nodes to return\n   * @param {Float} maxDistance - maximum distance of point to result nodes\n   * @return {Array} array of point, distance pairs\n   */\n  nearest(point: Float32Array, maxNodes: number, maxDistance: number) {\n    const bestNodes = new BinaryHeap<[number, number]>((e) => -e[1])\n\n    const nodes = this.nodes\n    const points = this.points\n    const indices = this.indices\n\n    const nearestSearch = (nodeIndex: number) => {\n      let bestChild, otherChild\n      const dimension = this.getNodeDepth(nodeIndex) % 3\n      const pointIndex = indices[nodes[nodeIndex]] * 3\n      const ownPoint = points.subarray(pointIndex, pointIndex + 3)\n      const ownDistance = this.metric(point, ownPoint)\n\n      function saveNode(nodeIndex: number, distance: number) {\n        bestNodes.push([nodeIndex, distance])\n        if (bestNodes.size() > maxNodes) {\n          bestNodes.pop()\n        }\n      }\n\n      const leftIndex = nodes[nodeIndex + 1]\n      const rightIndex = nodes[nodeIndex + 2]\n\n      // if it's a leaf\n      if (rightIndex === -1 && leftIndex === -1) {\n        if (\n          (bestNodes.size() < maxNodes || ownDistance < bestNodes.peek()[1]) &&\n          ownDistance <= maxDistance\n        ) {\n          saveNode(nodeIndex, ownDistance)\n        }\n        return\n      }\n\n      if (rightIndex === -1) {\n        bestChild = leftIndex\n      } else if (leftIndex === -1) {\n        bestChild = rightIndex\n      } else {\n        if (point[dimension] <= points[pointIndex + dimension]) {\n          bestChild = leftIndex\n        } else {\n          bestChild = rightIndex\n        }\n      }\n\n      // recursive search\n      nearestSearch(bestChild)\n\n      if (\n        (bestNodes.size() < maxNodes || ownDistance < bestNodes.peek()[1]) &&\n        ownDistance <= maxDistance\n      ) {\n        saveNode(nodeIndex, ownDistance)\n      }\n\n      // if there's still room or the current distance is nearer than the best distance\n      const linearPoint = reusableArray\n      for (let i = 0; i < 3; i += 1) {\n        if (i === dimension) {\n          linearPoint[i] = point[i]\n        } else {\n          linearPoint[i] = points[pointIndex + i]\n        }\n      }\n      const linearDistance = this.metric(linearPoint, ownPoint)\n\n      if (\n        (bestNodes.size() < maxNodes ||\n          Math.abs(linearDistance) < bestNodes.peek()[1]) &&\n        Math.abs(linearDistance) <= maxDistance\n      ) {\n        if (bestChild === leftIndex) {\n          otherChild = rightIndex\n        } else {\n          otherChild = leftIndex\n        }\n        if (otherChild !== -1) {\n          nearestSearch(otherChild)\n        }\n      }\n    }\n\n    nearestSearch(this.rootIndex)\n\n    const result = []\n    for (let i = 0, il = Math.min(bestNodes.size(), maxNodes); i < il; i += 1) {\n      result.push(bestNodes.content[i])\n    }\n\n    return result\n  }\n\n  verify(nodeIndex?: number, depth = 0) {\n    let count = 1\n\n    if (nodeIndex === undefined) {\n      nodeIndex = this.rootIndex\n    }\n\n    if (nodeIndex === -1) {\n      throw new Error('node is null')\n    }\n\n    const dim = depth % 3\n    const nodes = this.nodes\n    const points = this.points\n    const indices = this.indices\n\n    const leftIndex = nodes[nodeIndex + 1]\n    const rightIndex = nodes[nodeIndex + 2]\n\n    if (leftIndex !== -1) {\n      if (\n        points[indices[nodes[leftIndex]] * 3 + dim] >\n        points[indices[nodes[nodeIndex]] * 3 + dim]\n      ) {\n        throw new Error('left child is > parent!')\n      }\n      count += this.verify(leftIndex, depth + 1)\n    }\n\n    if (rightIndex !== -1) {\n      if (\n        points[indices[nodes[rightIndex]] * 3 + dim] <\n        points[indices[nodes[nodeIndex]] * 3 + dim]\n      ) {\n        throw new Error('right child is < parent!')\n      }\n      count += this.verify(rightIndex, depth + 1)\n    }\n\n    return count\n  }\n}\n\nexport default Kdtree\n","import './index.css'\n\nimport React from 'react'\nimport ReactDOM from 'react-dom'\nimport App from './App'\n\nReactDOM.render(<App />, document.getElementById('root'))\n"],"sourceRoot":""}