(this["webpackJsonpomovi-example"]=this["webpackJsonpomovi-example"]||[]).push([[0],{17:function(e,n,t){e.exports=t(25)},18:function(e,n,t){},24:function(e,n,t){},25:function(e,n,t){"use strict";t.r(n);t(18);var i,r=t(7),a=t.n(r),o=t(14),s=t.n(o),c=t(10),l=t(15),d=t(0),u=t(3),m=t(1),f=t(2),v=t(6),p=t(16),h=t.n(p),g=function(e){Object(m.a)(t,e);var n=Object(f.a)(t);function t(e,i){var r;return Object(d.a)(this,t),(r=n.call(this,i)).materialType=e,r.uniforms={},r.extensions={},r}return Object(u.a)(t,[{key:"copy",value:function(e){v.MeshPhongMaterial.prototype.copy.call(this,e);var n=e;return this.type=n.type,this.defines=Object(l.a)({},n.defines),this.uniforms=n.uniforms,this.onBeforeCompile=n.onBeforeCompile,this}},{key:"clone",value:function(){var e=new v.MeshPhongMaterial;return t.prototype.copy.call(e,this),e}}]),t}(v.MeshPhongMaterial),_={},x=new v.Matrix4,y=new v.Matrix4,b=new v.Matrix3,w=new v.Matrix3,M=function e(n){var t=this;Object(d.a)(this,e),this.add=function(e){if(e.material instanceof g){var n=e.material,i=n.type;null==t.materials[i]&&(t.materials[i]=n)}t.object.add(e)},this.setupLights=function(e,n,t){e.intensity=.3,n.intensity=.7,t.add(n),t.add(e)},this.setupCanvas=function(e){e.style.width="640px",e.style.height="480px",e.style.minWidth="100%",e.style.minHeight="100%",e.style.maxWidth="100%",e.style.maxHeight="100%"},this.setupCamera=function(e){e.position.set(10,10,10),e.lookAt(new v.Vector3(0,0,0))},this.updateUniforms=function(e){t.object.matrixWorld.copy(t.object.matrixWorld).invert(),y.copy(e.matrixWorldInverse).multiply(t.object.matrixWorld),b.getNormalMatrix(y),w.copy(b).invert(),Object.values(t.materials).forEach((function(e){null!=e.uniforms.inverseModelMatrix&&e.uniforms.inverseModelMatrix.value.copy(x),null!=e.uniforms.inverseNormalMatrix&&e.uniforms.inverseNormalMatrix.value.copy(w)}))},this.animate=function(){t.resizeIfNeeded(),t.controls.update(t.clock.getDelta()),t.updateUniforms(t.camera),t.renderer.render(t.scene,t.camera),t.latestRequestId=requestAnimationFrame(t.animate.bind(t))},this.resizeIfNeeded=function(){var e=t.renderer.getSize(new v.Vector2),n=e.width,i=e.height,r=0!==t.domElement.clientWidth?t.domElement.clientWidth:t.canvas.clientWidth,a=0!==t.domElement.clientHeight?t.domElement.clientHeight:t.canvas.clientHeight,o=window.devicePixelRatio*r,s=window.devicePixelRatio*a,c=o*s,l=c>14e5?Math.sqrt(14e5/c):1,d=o*l,u=s*l;return!(Math.abs(n-d)<.1&&Math.abs(i-u)<.1)&&(t.renderer.setSize(d,u),function(e,n,t){e instanceof v.PerspectiveCamera&&(e.aspect=n/t),e.updateProjectionMatrix()}(t.camera,d,u),!0)},this.renderer=new v.WebGLRenderer,this.canvas=this.renderer.domElement,this.domElement=n,this.domElement.appendChild(this.canvas),this.setupCanvas(this.canvas),this.scene=new v.Scene,this.ambientLight=new v.AmbientLight(16777215),this.directionalLight=new v.DirectionalLight(16777215),this.setupLights(this.ambientLight,this.directionalLight,this.scene),this.camera=new v.PerspectiveCamera(60,640/480,.1,1e4),this.setupCamera(this.camera),this.controls=new h.a(this.camera,this.canvas),this.latestRequestId=void 0,this.clock=new v.Clock,this.object=new v.Object3D,this.scene.add(this.object),this.materials={},this.animate()},P=function(e){var n=e.particles,t=Object(r.useRef)(null),o=Object(r.useState)(void 0),s=Object(c.a)(o,2),l=s[0],d=s[1];return Object(r.useEffect)((function(){t.current&&!i&&(i=new M(t.current),d(i),i.add(n.getMesh()))}),[t,l]),a.a.createElement("div",{style:{height:"100%",width:"100%"}},a.a.createElement("div",{style:{height:"100%",width:"100%"},ref:t}))},C=function(){function e(n){var t=this;Object(d.a)(this,e),this.getRadius=function(e){return t.radii[e]},this.getPosition=function(e){return new v.Vector3(t.positions[3*e+0],t.positions[3*e+1],t.positions[3*e+2])},this.getGeometry=function(){var e=new v.PlaneBufferGeometry(1,1,1,1),n=new v.InstancedBufferGeometry;return n.instanceCount=t.numParticles,n.setIndex(e.getIndex()),n.setAttribute("position",e.getAttribute("position")),n.setAttribute("normal",e.getAttribute("normal")),console.log("geometry: ",n),n.setAttribute("particlePosition",new v.InstancedBufferAttribute(t.positions,3,!1,1)),n.setAttribute("particleRadius",new v.InstancedBufferAttribute(t.radii,1,!1,1)),n},this.getMesh=function(){for(var e=t.getGeometry(),n=function(e,n,t){if(null!=_[e])return _[e];var i=new g(e,{color:16711680});return i.uniforms.inverseModelMatrix={value:new v.Matrix4},i.uniforms.inverseNormalMatrix={value:new v.Matrix3},i.onBeforeCompile=function(e){Object.assign(e.uniforms,i.uniforms),i.uniforms=e.uniforms,e.vertexShader=n,e.fragmentShader=t},i.onBeforeCompile.toString=function(){return e},_[e]=i,i}("particle","\n#define PHONG\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n#endif\n\nuniform mat4 inverseModelMatrix;\nattribute vec3 particlePosition;\nattribute float particleRadius;\n\nvarying vec3 vSurfacePoint;\nvarying vec3 vCenter;\nvarying float vRadius;\n\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvec3 makePerpendicular(vec3 v) {\n    if(v.x == 0.0 && v.y == 0.0) {\n        if(v.z == 0.0) {\n            return vec3(0.0, 0.0, 0.0);\n        }\n        return vec3(0.0, 1.0, 0.0);\n    }\n    return vec3(-v.y, v.x, 0.0);\n}\n\nvec3 mul3(mat4 M, vec3 v) {\n\tvec4 u = M * vec4(v, 1.0);\n\treturn u.xyz / u.w;\n}\n\nvoid main() {\n\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\n#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\n\n\tvNormal = normalize( transformedNormal );\n\n#endif\n\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t\n    vec4 mvPosition = vec4( transformed, 1.0 );\n\n    #ifdef USE_INSTANCING\n\n\tvec3 objectToCameraModelSpace = (inverseModelMatrix*vec4(particlePosition - cameraPosition, 1.0)).xyz;\n    vec3 view = normalize(objectToCameraModelSpace);\n    vec3 right = normalize(makePerpendicular(view));\n    vec3 up = cross(right, view);\n\t\n\t// Factor 2.0 is because geometry is 0.5x\n\tvec3 displacement = 2.0*particleRadius*(position.x * right + position.y * up);\n\t// particlePosition + displacement is the current vertex, also move closer to camera so billboard covers the sphere\n\ttransformed = particlePosition + displacement - particleRadius * view;\n\t\n\tvSurfacePoint = mul3(modelViewMatrix, transformed);\n    vCenter = mul3(modelViewMatrix, particlePosition);\n\tvRadius = particleRadius;\n    #endif\n\n    mvPosition = modelViewMatrix * vec4(transformed, 1.0);\n    gl_Position = projectionMatrix * mvPosition;\n\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\n\tvViewPosition = - mvPosition.xyz;\n\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n\n}\n","\n#define PHONG\n\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n\nvarying vec3 vSurfacePoint;\nvarying vec3 vCenter;\nvarying float vRadius;\n\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\n\tvec3 rayTarget = vSurfacePoint;\n\tvec3 rayDirection = normalize(rayTarget); // rayOrigin is (0,0,0) in camera space\n\n\tvec3 diff = rayTarget - vCenter.xyz;\n    vec3 E = diff;\n    vec3 D = rayDirection;\n\n    float a = dot(D, D);\n    float b = dot(E, D);\n    float c = dot(E, E) - vRadius*vRadius;\n\n    // discriminant of sphere equation (factor 2 removed from b above)\n    float d = b*b - a*c;\n    if(d < 0.0)\n        discard;\n\t\n    float sqrtd = sqrt(d);\n    float dist1 = (-b - sqrtd)/a;\n    float dist2 = (-b + sqrtd)/a;\n\n    // Make sure dist1 is the smaller one\n    if (dist2 < dist1) {\n        float tmp = dist1;\n        dist1 = dist2;\n        dist2 = tmp;\n    }\n\n    float dist = dist1;\n    float intersectionPointZ = E.z + dist*D.z;\n\tvec3 p = rayTarget + dist*rayDirection;\n\n\t// Find normal vector in local space\n    normal = normalize(vec3(p - vCenter.xyz));\n    // Transform into camera space\n    if (dot(normal, rayDirection) >  0.) {\n        normal = -normal;\n    }\n\n\t#include <emissivemap_fragment>\n\n\t// accumulation\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\n\t// modulation\n\t#include <aomap_fragment>\n\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\n\t#include <envmap_fragment>\n\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n\n}\n"),i=new v.InstancedMesh(e,n,t.numParticles),r=new v.Matrix4,a=0;a<t.numParticles;a++)i.setMatrixAt(a,r),i.setColorAt(a,new v.Color("red"));return i.frustumCulled=!1,i},this.positions=new Float32Array(3*n),this.indices=new Float32Array(n),this.radii=new Float32Array(n),this.numParticles=0,this.capacity=n}return Object(u.a)(e,[{key:"addParticle",value:function(e,n,t,i){if(this.numParticles!==this.capacity){var r=this.numParticles;this.positions[3*r+0]=e,this.positions[3*r+1]=n,this.positions[3*r+2]=t,this.radii[r]=i,this.indices[r]=r,this.numParticles+=1}else console.log("Warning, can't add particle because arrays are full")}}]),e}(),j=(t(24),function(){for(var e=2e5,n=new C(e),t=0;t<e;t++){var i=500*(Math.random()-.5),r=500*(Math.random()-.5),o=500*(Math.random()-.5),s=.5+Math.random();n.addParticle(i,r,o,s)}return a.a.createElement(P,{particles:n})});s.a.render(a.a.createElement(j,null),document.getElementById("root"))}},[[17,1,2]]]);
//# sourceMappingURL=main.ae0eff82.chunk.js.map