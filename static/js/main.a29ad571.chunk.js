(this["webpackJsonpomovi-example"]=this["webpackJsonpomovi-example"]||[]).push([[0],{18:function(n,e,t){n.exports=t(26)},19:function(n,e,t){},25:function(n,e,t){},26:function(n,e,t){"use strict";t.r(e);t(19);var i,r=t(7),a=t.n(r),o=t(15),s=t.n(o),c=t(11),l=t.n(c),u=t(12),m=t(9),d=t(16),f=t(0),p=t(3),h=t(1),v=t(2),g=t(5),_=t(17),b=t.n(_),x=function(n){Object(h.a)(t,n);var e=Object(v.a)(t);function t(n,i){var r;return Object(f.a)(this,t),(r=e.call(this,i)).materialType=n,r.uniforms={},r.extensions={},r.defines={},r}return Object(p.a)(t,[{key:"copy",value:function(n){g.MeshPhongMaterial.prototype.copy.call(this,n);var e=n;return this.type=e.type,this.defines=Object(d.a)({},e.defines),this.extensions=e.extensions,this.uniforms=e.uniforms,this.onBeforeCompile=e.onBeforeCompile,this}},{key:"clone",value:function(){var n=new g.MeshPhongMaterial;return t.prototype.copy.call(n,this),n}}]),t}(g.MeshPhongMaterial),y={};var w,M=function(n,e,t){if(null!=y[n])return y[n];var r=new x(n,{color:16777215});return r.uniforms.inverseModelMatrix={value:new g.Matrix4},r.uniforms.inverseNormalMatrix={value:new g.Matrix3},function(){if(void 0!==i)return i;var n=new g.WebGLRenderer,e=n.domElement.getContext("webgl");return i=!!(n.capabilities.isWebGL2||null!=e&&null!=e.getExtension("EXT_frag_depth")),n.dispose(),i}()&&(r.extensions.fragDepth=!0,r.defines.FRAG_DEPTH=1),r.onBeforeCompile=function(n){Object.assign(n.uniforms,r.uniforms),r.uniforms=n.uniforms,n.vertexShader=e,n.fragmentShader=t},r.onBeforeCompile.toString=function(){return n},y[n]=r,r},z=new g.Matrix4,P=new g.Matrix4,j=new g.Matrix3,D=new g.Matrix3,A=function n(e){var t=this;Object(f.a)(this,n),this.add=function(n){if(null!=n){if(n.material instanceof x){var e=n.material,i=e.type;null==t.materials[i]&&(t.materials[i]=e)}t.object.add(n)}},this.remove=function(n){t.object.remove(n)},this.setupLights=function(n,e,t){n.intensity=.3,e.intensity=.7,t.add(e),t.add(n)},this.setupCanvas=function(n){n.style.width="640px",n.style.height="480px",n.style.minWidth="100%",n.style.minHeight="100%",n.style.maxWidth="100%",n.style.maxHeight="100%"},this.setupCamera=function(n){n.position.set(10,10,10),n.lookAt(new g.Vector3(0,0,0))},this.updateUniforms=function(n){t.object.matrixWorld.copy(t.object.matrixWorld).invert(),P.copy(n.matrixWorldInverse).multiply(t.object.matrixWorld),j.getNormalMatrix(P),D.copy(j).invert(),Object.values(t.materials).forEach((function(n){null!=n.uniforms.inverseModelMatrix&&n.uniforms.inverseModelMatrix.value.copy(z),null!=n.uniforms.inverseNormalMatrix&&n.uniforms.inverseNormalMatrix.value.copy(D)}))},this.animate=function(){t.resizeIfNeeded(),t.controls.update(t.clock.getDelta()),t.updateUniforms(t.camera),t.renderer.render(t.scene,t.camera),t.latestRequestId=requestAnimationFrame(t.animate.bind(t))},this.resizeIfNeeded=function(){var n=t.renderer.getSize(new g.Vector2),e=n.width,i=n.height,r=0!==t.domElement.clientWidth?t.domElement.clientWidth:t.canvas.clientWidth,a=0!==t.domElement.clientHeight?t.domElement.clientHeight:t.canvas.clientHeight,o=window.devicePixelRatio*r,s=window.devicePixelRatio*a,c=o*s,l=c>14e5?Math.sqrt(14e5/c):1,u=o*l,m=s*l;return!(Math.abs(e-u)<.1&&Math.abs(i-m)<.1)&&(t.renderer.setSize(u,m),function(n,e,t){n instanceof g.PerspectiveCamera&&(n.aspect=e/t),n.updateProjectionMatrix()}(t.camera,u,m),!0)},this.renderer=new g.WebGLRenderer,this.canvas=this.renderer.domElement,this.domElement=e,this.domElement.appendChild(this.canvas),this.setupCanvas(this.canvas),this.scene=new g.Scene,this.ambientLight=new g.AmbientLight(16777215),this.directionalLight=new g.DirectionalLight(16777215),this.setupLights(this.ambientLight,this.directionalLight,this.scene),this.camera=new g.PerspectiveCamera(60,640/480,.1,1e4),this.setupCamera(this.camera),this.controls=new b.a(this.camera,this.canvas),this.latestRequestId=void 0,this.clock=new g.Clock,this.object=new g.Object3D,this.scene.add(this.object),this.materials={},this.animate()},C=function(n){var e=n.particles,t=n.bonds,i=Object(r.useRef)(null),o=Object(r.useState)(void 0),s=Object(m.a)(o,2),c=s[0],l=s[1];Object(r.useEffect)((function(){i.current&&!w&&(w=new A(i.current),l(w))}),[i,c]);var u=Object(r.useRef)();Object(r.useEffect)((function(){u.current=e}));var d=u.current,f=Object(r.useRef)();Object(r.useEffect)((function(){f.current=t}));var p=f.current;return Object(r.useEffect)((function(){c&&(d&&c.remove(d.getMesh()),e&&c.add(e.getMesh()),p&&c.remove(p.getMesh()),t&&c.add(t.getMesh()))}),[e,t,c]),a.a.createElement("div",{style:{height:"100%",width:"100%"}},a.a.createElement("div",{style:{height:"100%",width:"100%"},ref:i}))},E=function(){function n(e){var t=this;Object(f.a)(this,n),this.getRadius=function(n){return t.radii[n]},this.getPosition=function(n){return new g.Vector3(t.positions[3*n+0],t.positions[3*n+1],t.positions[3*n+2])},this.getType=function(n){return t.types[n]},this.getGeometry=function(){var n=new g.PlaneBufferGeometry(1,1,1,1),e=new g.InstancedBufferGeometry;return e.instanceCount=t.count,e.setIndex(n.getIndex()),e.setAttribute("position",n.getAttribute("position")),e.setAttribute("normal",n.getAttribute("normal")),e.setAttribute("particlePosition",new g.InstancedBufferAttribute(t.positions,3,!1,1)),e.setAttribute("particleRadius",new g.InstancedBufferAttribute(t.radii,1,!1,1)),e},this.getMesh=function(){if(null!=t.mesh)return t.mesh;var n=t.getGeometry(),e=M("particle","\n#define PHONG\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n#endif\n\nuniform mat4 inverseModelMatrix;\nattribute vec3 particlePosition;\nattribute float particleRadius;\n\nvarying vec3 vSurfacePoint;\nvarying vec3 vCenter;\nvarying float vRadius;\n\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvec3 makePerpendicular(vec3 v) {\n    if(v.x == 0.0 && v.y == 0.0) {\n        if(v.z == 0.0) {\n            return vec3(0.0, 0.0, 0.0);\n        }\n        return vec3(0.0, 1.0, 0.0);\n    }\n    return vec3(-v.y, v.x, 0.0);\n}\n\nvec3 mul3(mat4 M, vec3 v) {\n\tvec4 u = M * vec4(v, 1.0);\n\treturn u.xyz / u.w;\n}\n\nvoid main() {\n\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\n#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\n\n\tvNormal = normalize( transformedNormal );\n\n#endif\n\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t\n    vec4 mvPosition = vec4( transformed, 1.0 );\n\n    #ifdef USE_INSTANCING\n\n\tvec3 objectToCameraModelSpace = (inverseModelMatrix*vec4(particlePosition - cameraPosition, 1.0)).xyz;\n    vec3 view = normalize(objectToCameraModelSpace);\n    vec3 right = normalize(makePerpendicular(view));\n    vec3 up = cross(right, view);\n\t\n\t// Factor 2.0 is because geometry is 0.5x\n\tvec3 displacement = 2.0*particleRadius*(position.x * right + position.y * up);\n\t// particlePosition + displacement is the current vertex, also move closer to camera so billboard covers the sphere\n\ttransformed = particlePosition + displacement - particleRadius * view;\n\t\n\tvSurfacePoint = mul3(modelViewMatrix, transformed);\n    vCenter = mul3(modelViewMatrix, particlePosition);\n\tvRadius = particleRadius;\n    #endif\n\n    mvPosition = modelViewMatrix * vec4(transformed, 1.0);\n    gl_Position = projectionMatrix * mvPosition;\n\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\n\tvViewPosition = - mvPosition.xyz;\n\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n\n}\n","\n#define PHONG\n\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n\nuniform mat4 projectionMatrix;\nvarying vec3 vSurfacePoint;\nvarying vec3 vCenter;\nvarying float vRadius;\n\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\n\tvec3 rayTarget = vSurfacePoint;\n\tvec3 rayDirection = normalize(rayTarget); // rayOrigin is (0,0,0) in camera space\n\n\tvec3 diff = rayTarget - vCenter.xyz;\n    vec3 E = diff;\n    vec3 D = rayDirection;\n\n    float a = dot(D, D);\n    float b = dot(E, D);\n    float c = dot(E, E) - vRadius*vRadius;\n\n    // discriminant of sphere equation (factor 2 removed from b above)\n    float d = b*b - a*c;\n    if(d < 0.0)\n        discard;\n\t\n    float sqrtd = sqrt(d);\n    float dist1 = (-b - sqrtd)/a;\n    float dist2 = (-b + sqrtd)/a;\n\n    // Make sure dist1 is the smaller one\n    if (dist2 < dist1) {\n        float tmp = dist1;\n        dist1 = dist2;\n        dist2 = tmp;\n    }\n\n    float dist = dist1;\n    float intersectionPointZ = E.z + dist*D.z;\n\tvec3 p = rayTarget + dist*rayDirection;\n\n\t// Find normal vector in local space\n    normal = normalize(vec3(p - vCenter.xyz));\n    // Transform into camera space\n    if (dot(normal, rayDirection) >  0.) {\n        normal = -normal;\n    }\n\n#ifdef FRAG_DEPTH\n\tfloat projectedIntersection_z = projectionMatrix[0][2]*p.x + projectionMatrix[1][2]*p.y + projectionMatrix[2][2]*p.z + projectionMatrix[3][2];\n\tfloat projectedIntersection_w = projectionMatrix[0][3]*p.x + projectionMatrix[1][3]*p.y + projectionMatrix[2][3]*p.z + projectionMatrix[3][3];\n\tgl_FragDepthEXT = ((gl_DepthRange.diff * (projectedIntersection_z / projectedIntersection_w)) + gl_DepthRange.near + gl_DepthRange.far) * 0.5;\n#endif\n\n\t#include <emissivemap_fragment>\n\n\t// accumulation\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\n\t// modulation\n\t#include <aomap_fragment>\n\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\n\t#include <envmap_fragment>\n\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n\n}\n");t.mesh=new g.InstancedMesh(n,e,t.count);for(var i=new g.Matrix4,r=0;r<t.count;r++)t.mesh.setMatrixAt(r,i),t.mesh.setColorAt(r,t.colors[r]);return t.mesh.frustumCulled=!1,t.mesh},this.types=[],this.positions=new Float32Array(3*e),this.indices=new Float32Array(e),this.radii=new Float32Array(e),this.colors=[],this.count=0,this.capacity=e,this.mesh=void 0}return Object(p.a)(n,[{key:"add",value:function(n){var e=n.x,t=n.y,i=n.z,r=n.radius,a=n.type,o=void 0===a?"H":a,s=n.r,c=void 0===s?255:s,l=n.g,u=void 0===l?0:l,m=n.b,d=void 0===m?0:m;if(this.count!==this.capacity){var f=this.count;this.positions[3*f+0]=e,this.positions[3*f+1]=t,this.positions[3*f+2]=i,this.colors.push(new g.Color(c/255,u/255,d/255)),this.radii[f]=.25*r,this.indices[f]=f,this.types.push(o),this.count+=1}else console.log("Warning, can't add particle because arrays are full")}}]),n}(),R=function(){function n(e){var t=this;Object(f.a)(this,n),this.getRadius=function(n){return t.radii[n]},this.getPosition1=function(n){return new g.Vector3(t.positions1[3*n+0],t.positions1[3*n+1],t.positions1[3*n+2])},this.getGeometry=function(){var n=[];n.push(-1,1,-1),n.push(-1,-1,-1),n.push(1,1,-1),n.push(1,-1,-1),n.push(1,1,1),n.push(1,-1,1);var e=new g.BufferAttribute(new Float32Array(n),3),i=new g.BufferAttribute(new Uint16Array([1,2,0,1,3,2,3,4,2,3,5,4]),1),r=new g.InstancedBufferGeometry;return r.instanceCount=t.count,r.setIndex(i),r.setAttribute("position",e),r.setAttribute("normal",e),r.setAttribute("position1",new g.InstancedBufferAttribute(t.positions1,3,!1,1)),r.setAttribute("position2",new g.InstancedBufferAttribute(t.positions2,3,!1,1)),r.setAttribute("bondRadius",new g.InstancedBufferAttribute(t.radii,1,!1,1)),r},this.getMesh=function(){if(null!=t.mesh)return t.mesh;if(0===t.count)return null;var n=t.getGeometry(),e=M("bonds","\n#define PHONG\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n#endif\n\nuniform mat4 inverseModelMatrix;\nattribute vec3 position1;\nattribute vec3 position2;\nattribute float bondRadius;\n\nvarying vec4 v_position1;\nvarying vec4 v_position2;\n\n// U, V, axis represent the 3x3 cone basis.\n// They are vec4 to pack extra data into the w-component\n// since Safari on iOS only supports 8 varying vec4 registers.\nvarying vec4 U;\nvarying vec4 V;\nvarying vec4 axis;\nvarying float height;\n\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvec3 mul3(mat4 M, vec3 v) {\n\tvec4 u = M * vec4(v, 1.0);\n\treturn u.xyz / u.w;\n}\n\nvoid main() {\n\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\n#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\n\n\tvNormal = normalize( transformedNormal );\n\n#endif\n\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\n\tvec4 mvPosition = vec4( transformed, 1.0 );\n\n    // vec3 center = 0.5 * (position1 + position2);\n\tvec3 center = (inverseModelMatrix*vec4(0.5 * (position1 + position2), 1.0)).xyz;\n\theight = length(position2-position1);\n    vec3 newPosition = position;\n\t\n    vec3 objectToCameraModelSpace = (inverseModelMatrix*vec4(cameraPosition - center, 1.0)).xyz;\n\t\n    vec3 lDir = normalize(position1-position2);\n\tfloat dirSign = 1.0;\n    if (dot(objectToCameraModelSpace, lDir) < 0.0) { // direction vector looks away, flip it\n      dirSign = -1.0;\n      lDir *= -1.;\n    }\n\n    vec3 left = normalize(cross(objectToCameraModelSpace, lDir));\n    vec3 up = normalize(cross(left, lDir));\n\n\t// compute basis for cylinder\n    axis.xyz = lDir * dirSign;\n    U.xyz = cross(objectToCameraModelSpace, axis.xyz);\n    V.xyz = cross(U.xyz, axis.xyz);\n    // Transform to camera space\n    axis.xyz = normalize(normalMatrix * axis.xyz);\n    U.xyz = normalize(normalMatrix * U.xyz);\n    V.xyz = normalize(normalMatrix * V.xyz);\n\n\tv_position1.xyz = mul3(viewMatrix, mul3(modelMatrix, position1));\n    v_position2.xyz = mul3(viewMatrix, mul3(modelMatrix, position2));\n\n    // Pack radii as w components of v_centerA and v_centerB\n    v_position1.w = bondRadius;\n    v_position2.w = bondRadius;\n\n\tvec3 surfacePoint = center + mat3(0.5 * height * lDir, bondRadius * left, bondRadius * up) * newPosition;\n    transformed = surfacePoint;\n\n\tsurfacePoint = mul3(modelViewMatrix, surfacePoint);\n\n\t// We pack surfacePoint as w-components of U, V and axis\n    U.w = surfacePoint.x;\n    V.w = surfacePoint.y;\n    axis.w = surfacePoint.z;\n\n    mvPosition = modelViewMatrix * vec4(transformed, 1.0);\n    gl_Position = projectionMatrix * mvPosition;\n\t\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\n\tvViewPosition = - mvPosition.xyz;\n\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n\n}\n","\n#define PHONG\n\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n\nuniform mat4 projectionMatrix;\nvarying vec4 v_position1;\nvarying vec4 v_position2;\nvarying vec4 U;\nvarying vec4 V;\nvarying vec4 axis;\nvarying float height;\n\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\n\tmat3 basis = mat3(U.xyz, V.xyz, axis.xyz);\n    vec3 surfacePoint = vec3(U.w, V.w, axis.w);\n    vec3 rayTarget = surfacePoint;\n\tvec3 rayDirection = normalize(rayTarget); // rayOrigin is (0,0,0) in camera space\n\n\tvec3 diff = rayTarget - v_position2.xyz;\n    vec3 E = diff * basis;\n    float L = height;\n    vec3 D = rayDirection * basis;\n\n    float R1 = v_position1.w;\n    float R2 = v_position2.w;\n    float dR = R2 - R1;\n\n    float a = dot(D.xy, D.xy);\n    float b = dot(E.xy, D.xy);\n    float c = dot(E.xy, E.xy)-R1*R1;\n    float L2Inv = 1.0/(L*L);\n\n\t// Calculate a dicriminant of the above quadratic equation (factor 2 removed from all b-terms above)\n    float d = b*b - a*c;\n\n    // d < 0.0 means the ray hits outside an infinitely long eccentric cone\n    if (d < 0.0) {\n\t\tdiscard;\n    }\n\n\tfloat sqrtd = sqrt(d);\n    float dist1 = (-b - sqrtd)/a;\n    float dist2 = (-b + sqrtd)/a;\n\n    // Make sure dist1 is the smaller one\n    if (dist2 < dist1) {\n      float tmp = dist1;\n      dist1 = dist2;\n      dist2 = tmp;\n    }\n\n\t// Check the smallest root, it is closest camera. Only test if the z-component is outside the truncated eccentric cone\n    float dist = dist1;\n    float intersectionPointZ = E.z + dist*D.z;\n    // Intersection point in camera space\n    vec3 p = rayTarget + dist*rayDirection;\n    bool isInner = false;\n\n    if (intersectionPointZ <= 0.0 ||\n      intersectionPointZ >= L\n      ) {\n      // Either intersection point is behind starting point (happens inside the cone),\n      // or the intersection point is outside the end caps. This is not a valid solution.\n      isInner = true;\n      dist = dist2;\n      intersectionPointZ = E.z + dist*D.z;\n      p = rayTarget + dist*rayDirection;\n\n      if (intersectionPointZ <= 0.0 ||\n        intersectionPointZ >= L\n      ) {\n        // Missed the other point too\n\t\tdiscard;\n      }\n    }\n\n\t// Find normal vector\n    vec3 n = normalize(-axis.xyz);\n    vec3 position1 = v_position1.xyz;\n    vec3 position2 = v_position2.xyz;\n    vec3 A = cross(position1 - p, position2 - p);\n\n    vec3 t = normalize(cross(n, A));\n    vec3 o1 = position1 + R1 * t;\n    vec3 o2 = position2 + R2 * t;\n    vec3 B = o2-o1;\n    normal = normalize(cross(A, B));\n\n#ifdef FRAG_DEPTH\n\tfloat projectedIntersection_z = projectionMatrix[0][2]*p.x + projectionMatrix[1][2]*p.y + projectionMatrix[2][2]*p.z + projectionMatrix[3][2];\n\tfloat projectedIntersection_w = projectionMatrix[0][3]*p.x + projectionMatrix[1][3]*p.y + projectionMatrix[2][3]*p.z + projectionMatrix[3][3];\n\tgl_FragDepthEXT = ((gl_DepthRange.diff * (projectedIntersection_z / projectedIntersection_w)) + gl_DepthRange.near + gl_DepthRange.far) * 0.5;\n#endif\n\n\t#include <emissivemap_fragment>\n\n\t// accumulation\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\n\t// modulation\n\t#include <aomap_fragment>\n\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\n\t#include <envmap_fragment>\n\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n  \n}\n\n");t.mesh=new g.InstancedMesh(n,e,t.count);for(var i=new g.Matrix4,r=0;r<t.count;r++)t.mesh.setMatrixAt(r,i),t.mesh.setColorAt(r,t.colors[r]);return t.mesh.frustumCulled=!1,t.mesh},this.positions1=new Float32Array(3*e),this.positions2=new Float32Array(3*e),this.indices=new Float32Array(e),this.radii=new Float32Array(e),this.colors=[],this.count=0,this.capacity=e,this.mesh=void 0}return Object(p.a)(n,[{key:"add",value:function(n,e,t,i,r,a,o){var s=arguments.length>7&&void 0!==arguments[7]?arguments[7]:255,c=arguments.length>8&&void 0!==arguments[8]?arguments[8]:255,l=arguments.length>9&&void 0!==arguments[9]?arguments[9]:255;if(this.count!==this.capacity){var u=this.count;this.positions1[3*u+0]=n,this.positions1[3*u+1]=e,this.positions1[3*u+2]=t,this.positions2[3*u+0]=i,this.positions2[3*u+1]=r,this.positions2[3*u+2]=a,this.colors.push(new g.Color(s/255,c/255,l/255)),this.radii[u]=.25*o,this.indices[u]=u,this.count+=1}else console.log("Warning, can't add particle because arrays are full")}}]),n}(),k={H:{shortname:"H",fullname:"hydrogen",radius:1.2,color:{r:204,g:204,b:204}},He:{shortname:"He",fullname:"helium",radius:1.4,color:{r:217,g:255,b:255}},Li:{shortname:"Li",fullname:"lithium",radius:1.82,color:{r:204,g:128,b:255}},Be:{shortname:"Be",fullname:"beryllium",radius:1.53,color:{r:194,g:255,b:0}},B:{shortname:"B",fullname:"boron",radius:1.92,color:{r:255,g:181,b:181}},C:{shortname:"C",fullname:"carbon",radius:1.7,color:{r:80,g:80,b:80}},N:{shortname:"N",fullname:"nitrogen",radius:1.55,color:{r:48,g:80,b:248}},O:{shortname:"O",fullname:"oxygen",radius:1.52,color:{r:170,g:0,b:0}},F:{shortname:"F",fullname:"fluorine",radius:1.35,color:{r:144,g:224,b:80}},Ne:{shortname:"Ne",fullname:"neon",radius:1.54,color:{r:48,g:80,b:248}},Na:{shortname:"Na",fullname:"sodium",radius:2.27,color:{r:171,g:92,b:242}},Mg:{shortname:"Mg",fullname:"magnesium",radius:1.73,color:{r:138,g:255,b:0}},Al:{shortname:"Al",fullname:"aluminium",radius:1.84,color:{r:191,g:166,b:166}},Si:{shortname:"Si",fullname:"silicon",radius:2.27,color:{r:240,g:200,b:160}},P:{shortname:"P",fullname:"phosphorus",radius:1.8,color:{r:255,g:128,b:0}},S:{shortname:"S",fullname:"sulfur",radius:1.8,color:{r:255,g:255,b:48}},Cl:{shortname:"Cl",fullname:"chlorine",radius:1.75,color:{r:31,g:240,b:31}},Ar:{shortname:"Ar",fullname:"argon",radius:1.88,color:{r:128,g:209,b:227}},K:{shortname:"K",fullname:"potassium",radius:2.75,color:{r:143,g:64,b:212}},Ca:{shortname:"Ca",fullname:"calcium",radius:2.31,color:{r:61,g:255,b:0}},Sc:{shortname:"Sc",fullname:"scandium",radius:2.11,color:{r:230,g:230,b:230}},Ti:{shortname:"Ti",fullname:"titanium",radius:2,color:{r:191,g:194,b:199}},V:{shortname:"V",fullname:"vanadium",radius:2,color:{r:166,g:166,b:171}},Cr:{shortname:"Cr",fullname:"chromium",radius:2,color:{r:138,g:153,b:199}},Mn:{shortname:"Mn",fullname:"manganese",radius:2,color:{r:156,g:122,b:199}},Fe:{shortname:"Fe",fullname:"iron",radius:2,color:{r:224,g:102,b:51}},Co:{shortname:"Co",fullname:"cobalt",radius:2,color:{r:240,g:144,b:160}},Ni:{shortname:"Ni",fullname:"nickel",radius:1.63,color:{r:80,g:208,b:80}},Cu:{shortname:"Cu",fullname:"copper",radius:1.4,color:{r:200,g:128,b:51}},Zn:{shortname:"Zn",fullname:"zinc",radius:1.39,color:{r:125,g:128,b:176}},Ga:{shortname:"Ga",fullname:"gallium",radius:1.87,color:{r:194,g:143,b:143}},Ge:{shortname:"Ge",fullname:"germanium",radius:2.11,color:{r:102,g:143,b:143}},As:{shortname:"As",fullname:"arsenic",radius:1.85,color:{r:189,g:128,b:227}},Se:{shortname:"Se",fullname:"selenium",radius:1.9,color:{r:255,g:161,b:0}},Br:{shortname:"Br",fullname:"bromine",radius:1.85,color:{r:166,g:41,b:41}},Kr:{shortname:"Kr",fullname:"krypton",radius:2.02,color:{r:92,g:184,b:209}},Rb:{shortname:"Rb",fullname:"rubidium",radius:3.03,color:{r:112,g:46,b:176}},Sr:{shortname:"Sr",fullname:"strontium",radius:2.49,color:{r:0,g:255,b:0}},Y:{shortname:"Y",fullname:"yttrium",radius:2,color:{r:148,g:255,b:255}},Zr:{shortname:"Zr",fullname:"zirconium",radius:2,color:{r:148,g:224,b:224}},Nb:{shortname:"Nb",fullname:"niobium",radius:2,color:{r:115,g:194,b:201}},Mo:{shortname:"Mo",fullname:"molybdenum",radius:2,color:{r:84,g:181,b:181}},Tc:{shortname:"Tc",fullname:"technetium",radius:2,color:{r:59,g:158,b:158}},Ru:{shortname:"Ru",fullname:"ruthenium",radius:2,color:{r:36,g:143,b:143}},Rh:{shortname:"Rh",fullname:"rhodium",radius:2,color:{r:10,g:125,b:140}},Pd:{shortname:"Pd",fullname:"palladium",radius:1.63,color:{r:0,g:105,b:133}},Ag:{shortname:"Ag",fullname:"silver",radius:1.72,color:{r:192,g:192,b:192}},Cd:{shortname:"Cd",fullname:"cadmium",radius:1.58,color:{r:255,g:217,b:143}},In:{shortname:"In",fullname:"indium",radius:1.93,color:{r:166,g:117,b:115}},Sn:{shortname:"Sn",fullname:"tin",radius:2.17,color:{r:102,g:128,b:128}},Sb:{shortname:"Sb",fullname:"antimony",radius:2.06,color:{r:158,g:99,b:181}},Te:{shortname:"Te",fullname:"tellurium",radius:2.06,color:{r:212,g:122,b:0}},I:{shortname:"I",fullname:"iodine",radius:1.98,color:{r:148,g:0,b:148}},Xe:{shortname:"Xe",fullname:"xenon",radius:2.16,color:{r:66,g:158,b:176}},Cs:{shortname:"Cs",fullname:"caesium",radius:3.43,color:{r:87,g:23,b:143}},Ba:{shortname:"Ba",fullname:"barium",radius:2.68,color:{r:0,g:201,b:0}},La:{shortname:"La",fullname:"lanthanum",radius:2,color:{r:112,g:212,b:255}},Ce:{shortname:"Ce",fullname:"cerium",radius:2,color:{r:255,g:255,b:199}},Pr:{shortname:"Pr",fullname:"praseodymium",radius:2,color:{r:217,g:255,b:199}},Nd:{shortname:"Nd",fullname:"neodymium",radius:2,color:{r:199,g:255,b:199}},Pm:{shortname:"Pm",fullname:"promethium",radius:2,color:{r:163,g:255,b:199}},Sm:{shortname:"Sm",fullname:"samarium",radius:2,color:{r:143,g:255,b:199}},Eu:{shortname:"Eu",fullname:"europium",radius:2,color:{r:97,g:255,b:199}},Gd:{shortname:"Gd",fullname:"gadolinium",radius:2,color:{r:69,g:255,b:199}},Tb:{shortname:"Tb",fullname:"terbium",radius:2,color:{r:48,g:255,b:199}},Dy:{shortname:"Dy",fullname:"dysprosium",radius:2,color:{r:31,g:255,b:199}},Ho:{shortname:"Ho",fullname:"holmium",radius:2,color:{r:0,g:255,b:156}},Er:{shortname:"Er",fullname:"erbium",radius:2,color:{r:0,g:230,b:117}},Tm:{shortname:"Tm",fullname:"thulium",radius:2,color:{r:0,g:212,b:82}},Yb:{shortname:"Yb",fullname:"ytterbium",radius:2,color:{r:0,g:191,b:56}},Lu:{shortname:"Lu",fullname:"lutetium",radius:2,color:{r:0,g:171,b:36}},Hf:{shortname:"Hf",fullname:"hafnium",radius:2,color:{r:77,g:194,b:255}},Ta:{shortname:"Ta",fullname:"tantalum",radius:2,color:{r:77,g:166,b:255}},W:{shortname:"W",fullname:"tungsten",radius:2,color:{r:33,g:148,b:214}}},T=function n(){var e=this;Object(f.a)(this,n),this.getFrame=function(n){var t=e.frames[n];if(e.generateBondsFunction&&null==t.bonds){var i=e.generateBondsFunction(t);i.count>0&&(t.bonds=i)}return t},this.getNumFrames=function(){return e.frames.length},this.frames=[]},S=function n(e){Object(f.a)(this,n),this.particles=e};function F(n,e,t){for(var i=0;i<t.capacity;i++){var r=n[e+i].split(/\s+/).filter(Boolean),a=r[0],o=k[a],s={r:255,g:102,b:102},c=1;o&&(c=o.radius,s=o.color);var l=parseFloat(r[1]),u=parseFloat(r[2]),m=parseFloat(r[3]);t.add({x:l,y:u,z:m,radius:c,r:s.r,g:s.g,b:s.b,type:o.shortname})}}var L=function(n){for(var e,t=[],i=n.split("\n"),r=i.length,a=0,o=!1,s=!0;a<r;)if(""!==i[a]){if(o)o=!1;else if(s){var c=parseInt(i[a],10);if(isNaN(c)){console.log("Warning, got NaN as numParticles");break}e=new E(c),s=!1,o=!0}else if(e){F(i,a,e);var l=new S(e);t.push(l),a+=e.count-1,s=!0}a++}else a++;var u=new T;return u.frames=t,u},N=function(){function n(e){Object(f.a)(this,n),this.scoreFunction=e,this.content=[],this.scoreFunction=e}return Object(p.a)(n,[{key:"push",value:function(n){this.content.push(n),this.bubbleUp(this.content.length-1)}},{key:"pop",value:function(){var n=this.content[0],e=this.content.pop();return e&&this.content.length>0&&(this.content[0]=e,this.sinkDown(0)),n}},{key:"peek",value:function(){return this.content[0]}},{key:"remove",value:function(n){for(var e=this.content.length,t=0;t<e;t++)if(this.content[t]===n){var i=this.content.pop();return void(i&&t!==e-1&&(this.content[t]=i,this.scoreFunction(i)<this.scoreFunction(n)?this.bubbleUp(t):this.sinkDown(t)))}throw new Error("Node not found.")}},{key:"size",value:function(){return this.content.length}},{key:"bubbleUp",value:function(n){for(var e=this.content[n];n>0;){var t=Math.floor((n+1)/2)-1,i=this.content[t];if(!(this.scoreFunction(e)<this.scoreFunction(i)))break;this.content[t]=e,this.content[n]=i,n=t}}},{key:"sinkDown",value:function(n){for(var e=this.content.length,t=this.content[n],i=this.scoreFunction(t),r=0;;){var a=2*(n+1),o=a-1,s=null;if(o<e){var c=this.content[o];(r=this.scoreFunction(c))<i&&(s=o)}if(a<e){var l=this.content[a];this.scoreFunction(l)<(null===s?i:r)&&(s=a)}if(null===s)break;this.content[n]=this.content[s],this.content[s]=t,n=s}}}]),n}(),O=new Float32Array(3),I=function(){function n(e,t){Object(f.a)(this,n),this.points=e,this.metric=t,this.maxDepth=0,this.currentNode=0;for(var i=e.length/3,r=new Uint32Array(i),a=0;a<i;++a)r[a]=a;this.indices=r,this.nodes=new Int32Array(4*i),this.rootIndex=this.buildTree(0,-1,0,i)}return Object(p.a)(n,[{key:"buildTree",value:function(n,e,t,i){n>this.maxDepth&&(this.maxDepth=n);var r=i-t;if(0===r)return-1;var a=4*this.currentNode,o=this.nodes;if(this.currentNode+=1,1===r)return o[a]=t,o[a+1]=-1,o[a+2]=-1,o[a+3]=e,a;for(var s,c,l,u,m,d=this.indices,f=this.points,p=t+Math.floor(r/2),h=n%3,v=t,g=i-1;g>v;){for(u=f[3*d[l=v+g>>1]+h],c=d[l],d[l]=d[g],d[g]=c,m=v,s=v;s<g;++s)f[3*d[s]+h]<u&&(c=d[m],d[m]=d[s],d[s]=c,++m);if(c=d[g],d[g]=d[m],d[m]=c,p===(l=m))break;p<l?g=l-1:v=l+1}return o[a]=p,o[a+1]=this.buildTree(n+1,a,t,p),o[a+2]=this.buildTree(n+1,a,p+1,i),o[a+3]=e,a}},{key:"getNodeDepth",value:function(n){var e=this.nodes[n+3];return-1===e?0:this.getNodeDepth(e)+1}},{key:"nearest",value:function(n,e,t){var i=this,r=new N((function(n){return-n[1]})),a=this.nodes,o=this.points,s=this.indices;!function c(l){var u,m,d=i.getNodeDepth(l)%3,f=3*s[a[l]],p=o.subarray(f,f+3),h=i.metric(n,p);function v(n,t){r.push([n,t]),r.size()>e&&r.pop()}var g=a[l+1],_=a[l+2];if(-1!==_||-1!==g){c(u=-1===_?g:-1===g?_:n[d]<=o[f+d]?g:_),(r.size()<e||h<r.peek()[1])&&h<=t&&v(l,h);for(var b=O,x=0;x<3;x+=1)b[x]=x===d?n[x]:o[f+x];var y=i.metric(b,p);(r.size()<e||Math.abs(y)<r.peek()[1])&&Math.abs(y)<=t&&-1!==(m=u===g?_:g)&&c(m)}else(r.size()<e||h<r.peek()[1])&&h<=t&&v(l,h)}(this.rootIndex);for(var c=[],l=0,u=Math.min(r.size(),e);l<u;l+=1)c.push(r.content[l]);return c}},{key:"verify",value:function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,t=1;if(void 0===n&&(n=this.rootIndex),-1===n)throw new Error("node is null");var i=e%3,r=this.nodes,a=this.points,o=this.indices,s=r[n+1],c=r[n+2];if(-1!==s){if(a[3*o[r[s]]+i]>a[3*o[r[n]]+i])throw new Error("left child is > parent!");t+=this.verify(s,e+1)}if(-1!==c){if(a[3*o[r[c]]+i]<a[3*o[r[n]]+i])throw new Error("right child is < parent!");t+=this.verify(c,e+1)}return t}}]),n}(),B=function(n){var e=n.radius,t=void 0===e?.5:e,i=n.pairDistances,r=void 0===i?[]:i;return function(n){var e=n.particles,i={};r.forEach((function(n){null==i[n.type1]&&(i[n.type1]={}),null==i[n.type2]&&(i[n.type2]={}),i[n.type1][n.type2]=n.distance,i[n.type2][n.type1]=n.distance}));for(var a={},o=new I(e.positions.subarray(0,3*e.count),(function(n,e){return Math.pow(n[0]-e[0],2)+Math.pow(n[1]-e[1],2)+Math.pow(n[2]-e[2],2)})),s=[],c=[],l=0;l<e.count;l++){var u=e.getType(l);if(null!=i[u])for(var m=o.nearest(e.positions.subarray(3*l,3*(l+1)),4,1.4),d=0;d<m.length;d++){var f=m[d][0],p=o.indices[o.nodes[f]];if(p!==l){var h=e.getType(p);if(null!=i[u][h]){var v=i[u][h];if(!(m[d][1]>v)){var g=p<l?"".concat(p,"-").concat(l):"".concat(l,"-").concat(p);null==a[g]&&(s.push(e.getPosition(l)),c.push(e.getPosition(p)),a[g]=!0)}}}}}for(var _=new R(s.length),b=0;b<s.length;b++)_.add(s[b].x,s[b].y,s[b].z,c[b].x,c[b].y,c[b].z,t);return _}},H=(t(25),function(){var n=Object(r.useState)(),e=Object(m.a)(n,2),t=e[0],i=e[1],o=Object(r.useState)(0),s=Object(m.a)(o,2),c=s[0],d=s[1];if(Object(r.useEffect)((function(){(function(){var n=Object(u.a)(l.a.mark((function n(){var e,t;return l.a.wrap((function(n){for(;;)switch(n.prev=n.next){case 0:return n.next=2,fetch("https://raw.githubusercontent.com/andeplane/simulations/main/water.xyz");case 2:return e=n.sent,n.t0=L,n.next=6,e.text();case 6:n.t1=n.sent,(t=(0,n.t0)(n.t1)).generateBondsFunction=B({radius:.5,pairDistances:[{type1:"H",type2:"O",distance:1.4}]}),i(t);case 10:case"end":return n.stop()}}),n)})));return function(){return n.apply(this,arguments)}})()()}),[]),setTimeout((function(){if(null!=t){var n=c+1;n>=t.getNumFrames()&&(n=0),d(n)}}),50),null==t)return a.a.createElement(a.a.Fragment,null,"Downloading simulation data ...");var f=t.getFrame(c);return a.a.createElement(C,{particles:f.particles,bonds:f.bonds})});s.a.render(a.a.createElement(H,null),document.getElementById("root"))}},[[18,1,2]]]);
//# sourceMappingURL=main.a29ad571.chunk.js.map